<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eloquent Programmer</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://paruka.me/"/>
  <updated>2017-08-30T14:53:51.240Z</updated>
  <id>http://paruka.me/</id>
  
  <author>
    <name>Paruka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>条款33：在对auto&amp;&amp;参数执行std::forward时使用decltype</title>
    <link href="http://paruka.me/translation/effective_modern_cpp/item33.html"/>
    <id>http://paruka.me/translation/effective_modern_cpp/item33.html</id>
    <published>2017-08-30T07:53:00.000Z</published>
    <updated>2017-08-30T14:53:51.240Z</updated>
    
    <content type="html"><![CDATA[<div id="content">
<p>
<b>C++14</b> 中最令人兴奋的特性之一便是 <i>泛型lambda</i> ──可用 <b>auto</b> 声明lambda函数的参数。这一特性的实现很直白：将该lambda闭包类的 <b>operator()</b> 实现为一模板。以如下 <b>lambda</b> 为例：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">f</span> = [](<span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x</span>) { <span style="color: #a1db00;">return</span> func(normalize(x)); };
</pre>
</div>
<p>
其闭包类的函数调用操作符大致如下：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">SomeCompilerGeneratedClassName</span> {
<span class="linenr">2 </span><span style="color: #a1db00;">public</span>:
<span class="linenr">3 </span>    <span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">see Item 3 for</span>
<span class="linenr">4 </span>    <span style="color: #a1db00;">auto</span> <span style="color: #a1db00;">operator</span> <span style="color: #ffd700;">()</span>(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">x</span>) <span style="color: #a1db00;">const</span>        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">auto return type</span>
<span class="linenr">5 </span>    { <span style="color: #a1db00;">return</span> func(<span style="color: #00d7af;">normalize</span>(<span style="color: #ff8700;">x</span>)); }
<span class="linenr">6 </span>
<span class="linenr">7 </span>    ...                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">other closure class</span>
<span class="linenr">8 </span>};                                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">functionality</span>
</pre>
</div>

<a id="more"></a>

<p>
此例中， <b>lambda</b> 所做的事情仅仅是将参数 <b>x</b> 转发给 <b>normalize</b> 。如果 <b>normalize</b> 区分左右值，此lambda便是错误的，因为它总是传递一左值（参数 <b>x</b> ）给 <b>normalize</b> ，即便它的实参是一个右值。
</p>

<p>
该 <b>lambda</b> 的正确写法是将其参数 <b>x</b> 完美转发给 <b>normalize</b> 。因此需对代码做两个修改。第一，将 <b>x</b> 改为通用引用（参考 <a href="./item24.html">条款24</a>），第二，使用 <b>std::forward</b> 将 <b>x</b> 转发给 <b>normalize</b> （参考<a href="./item25.html">条款25</a>），大概如下，都是一些琐碎的修改：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">f</span> = [](<span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">x</span>)
<span class="linenr">2 </span>         { <span style="color: #a1db00;">return</span> func(normalize(<span style="color: #5fafd7;">std</span>::forward&lt;???&gt;(x))); };
</pre>
</div>

<p>
在大概与现实之间，有一个问题夹杂其中：传递给 <b>std::forward</b> 的应该是什么类型，以上代码的 <b>???</b> 部分该如何编写？
</p>

<p>
通常，在使用完美转发时，你正处于一类型参数为 <b>T</b> 的模板函数之中，因此，只需编写 <b>std::forward&lt;T&gt;</b> 即可。但在泛型lambda中并没有类型参数 <b>T</b> 。 <b>T</b> 只存在于由此 <b>lambda</b> 函数生成的闭包类的模板化 <b>operator()</b> 函数中，可我们无法在lambda函数中引用它，因此，它毫无作用。
</p>

<p>
<a href="./item28.html">条款28</a>讲道，对于通用引用类型的形参，传入左值实参，则形参类型为左值引用；传入右值实参，则形参类型为右值引用。这意味着在lambda函数中，我们可以通过检查形参 <b>x</b> 的类型来判断传入的实参是左值还是右值。 <b>decltype</b> 给予了我们这一能力（参考<a href="./item3.html">条款3</a>）。如果传入的是左值， <b>decltype(x)</b> 将产生一左值引用 <b>类型</b> 。如果传入的是右值， <b>decltype(x)</b> 将产生一右值引用 <b>类型</b> 。
</p>

<p>
<a href="./item28.html">条款28</a>同样讲到，在调用 <b>std::forward</b> 时，规定：传入的类型参数为左值引用时返回一左值，非引用类型则返回一右值。在我们的lambda函数中，若 <b>x</b> 绑定至左值， <b>decltype(x)</b> 将产生一左值引用。这是符合规则的。但当 <b>x</b> 绑定至右值时， <b>decltype</b> 将产生一右值引用，而不是非引用类型。
</p>

<p>
回看<a href="./item28.html">条款28</a>给出的 <b>std::forward</b> 的 <b>C++14</b> 实现：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;                             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">in namespace</span>
<span class="linenr">2 </span><span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ffd700;">forward</span>(<span style="color: #00d7af;">remove_reference_t</span>&lt;<span style="color: #00d7af;">T</span>&gt;&amp; <span style="color: #ff8700;">param</span>)        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std</span>
<span class="linenr">3 </span>{
<span class="linenr">4 </span>    <span style="color: #a1db00;">return</span> <span style="color: #a1db00;">static_cast</span>&lt;<span style="color: #00d7af;">T</span>&amp;&amp;&gt;(param);
<span class="linenr">5 </span>}
</pre>
</div>

<p>
如果客户代码想要完美转发一 <b>Widget</b> 类型的右值，它通常会用 <b>Widget</b> 类型（既非引用类型）实例化 <b>std::forward</b> ，所以 <b>std::forward</b> 模板生成如下函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ffd700;">forward</span>(<span style="color: #00d7af;">Widget</span>&amp; <span style="color: #ff8700;">param</span>)              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">instantiation of</span>
<span class="linenr">2 </span>{                                            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std::forward when</span>
<span class="linenr">3 </span>    <span style="color: #a1db00;">return</span> <span style="color: #a1db00;">static_cast</span>&lt;<span style="color: #00d7af;">Widget</span>&amp;&amp;&gt;(param);     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is Widget</span>
<span class="linenr">4 </span>}
</pre>
</div>

<p>
但考虑一下，若客户代码想完美转发该 <b>Widget</b> 类型的右值，却没有遵循指定 <b>T</b> 为非引用类型的规定，而是将其设为右值引用，会发生什么。想象一下 <b>T</b> 为 <b>Widget&amp;&amp;</b> 。 在实例化 <b>std::forward</b> 并调用 <b>std::remove_reference_t</b> 之后，引用折叠（再次参考<a href="./item28.html">条款28</a>）触发之前， <b>std::forward</b> 看起来会是这样的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">Widget</span>&amp;&amp; &amp;&amp; <span style="color: #ffd700;">forward</span>(<span style="color: #00d7af;">Widget</span>&amp; <span style="color: #ff8700;">param</span>)              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">instantiation of</span>
<span class="linenr">2 </span>{                                               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std::forward when</span>
<span class="linenr">3 </span>    <span style="color: #a1db00;">return</span> <span style="color: #a1db00;">static_cast</span>&lt;<span style="color: #00d7af;">Widget</span>&amp;&amp; &amp;&amp;&gt;(param);     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is Widget&amp;&amp;</span>
<span class="linenr">4 </span>}                                               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">(before reference-</span>
<span class="linenr">5 </span>                                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">collapsing)</span>
</pre>
</div>

<p>
应用引用折叠规则 —— <b>右值引用的右值引用为一右值引用（简单理解为&amp;&amp; + &amp;&amp; = &amp;&amp;）</b> 之后，真相便浮出水面：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ffd700;">forward</span>(<span style="color: #00d7af;">Widget</span>&amp; <span style="color: #ff8700;">param</span>)               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">instantiation of</span>
<span class="linenr">2 </span>{                                             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std::forward when</span>
<span class="linenr">3 </span>    <span style="color: #a1db00;">return</span> <span style="color: #a1db00;">static_cast</span>&lt;<span style="color: #00d7af;">Widget</span>&amp;&amp;&gt;(param);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is Widget&amp;&amp;</span>
<span class="linenr">4 </span>}                                             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">(after reference-</span>
<span class="linenr">5 </span>                                              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">collapsing)</span>
</pre>
</div>

<p>
如果你把该实例化版本与 <b>T</b> 为 <b>Widget</b> 的那个 <b>std::forward</b> 实例化版本相比较，你会发觉它们是相同的。这意味着用右值引用实例化 <b>std::forward</b> 与用非引用类型实例化它是一样的结果。
</p>

<p>
这是极好的，因为当将一右值传递给lambda函数的形参 <b>x</b> 时， <b>decltype(x)</b> 将生成一右值引用类型。我们在上面已经确认，当传入一左值给lambda时， <b>decltype(x)</b> 会生成一常规类型传递给 <b>std::forward</b> ，而现在我们知道，对于右值 <b>decltype(x)</b> 生成的传递给 <b>std::forward</b> 的类型是非常规的，但结果却与常规类型相同。所以，无论是左值还是右值，将 <b>decltype(x)</b> 传递给 <b>std::forward</b> 都能得到我们期望的结果。因此，我们的完美转发lambda便是这是编写的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">f</span> =
<span class="linenr">2 </span>  [](<span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">param</span>)
<span class="linenr">3 </span>  {
<span class="linenr">4 </span>    <span style="color: #a1db00;">return</span>
<span class="linenr">5 </span>      func(normalize(<span style="color: #5fafd7;">std</span>::forward&lt;<span style="color: #a1db00;">decltype</span>(param)&gt;(param)));
<span class="linenr">6 </span>  };
</pre>
</div>

<p>
对它稍作修改，只需6个点号，便可接受任意个数的参数<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>，因为 <b>C++14</b> 的lambda可以是变参的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">f</span> =
<span class="linenr">2 </span>  [](<span style="color: #a1db00;">auto</span>&amp;&amp;... params)
<span class="linenr">3 </span>  {
<span class="linenr">4 </span>    <span style="color: #a1db00;">return</span>
<span class="linenr">5 </span>    func(normalize(<span style="color: #5fafd7;">std</span>::forward&lt;<span style="color: #a1db00;">decltype</span>(param)&gt;(params)...));
<span class="linenr">6 </span>  };
</pre>
</div>

<div id="outline-container-org65e2633" class="outline-2">
<h2 id="org65e2633">记住</h2>
<div class="outline-text-2" id="text-org65e2633">
<ul class="org-ul">
<li>在对 <b>auto&amp;&amp;</b> 参数执行 <b>std::forward</b> 时使用 <b>decltype</b> 。</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<i>From there, it's just a hop, skip, and six dots to a perfect-forwarding lambda that accepts not just a single paramater, but any number of parameters.</i> 这里 <b>a hop,skip and jump</b> 是三级跳的意思 第一步小 第二步大 第三步更大,所以也有势头越来越猛,速度越来越快的意思
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-30 Wed 22:53</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;
&lt;p&gt;
&lt;b&gt;C++14&lt;/b&gt; 中最令人兴奋的特性之一便是 &lt;i&gt;泛型lambda&lt;/i&gt; ──可用 &lt;b&gt;auto&lt;/b&gt; 声明lambda函数的参数。这一特性的实现很直白：将该lambda闭包类的 &lt;b&gt;operator()&lt;/b&gt; 实现为一模板。以如下 &lt;b&gt;lambda&lt;/b&gt; 为例：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-C++&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1 &lt;/span&gt;&lt;span style=&quot;color: #a1db00;&quot;&gt;auto&lt;/span&gt; &lt;span style=&quot;color: #ff8700;&quot;&gt;f&lt;/span&gt; = [](&lt;span style=&quot;color: #a1db00;&quot;&gt;auto&lt;/span&gt; &lt;span style=&quot;color: #ff8700;&quot;&gt;x&lt;/span&gt;) { &lt;span style=&quot;color: #a1db00;&quot;&gt;return&lt;/span&gt; func(normalize(x)); };
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
其闭包类的函数调用操作符大致如下：
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;
&lt;pre class=&quot;src src-C++&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1 &lt;/span&gt;&lt;span style=&quot;color: #a1db00;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color: #00d7af;&quot;&gt;SomeCompilerGeneratedClassName&lt;/span&gt; {
&lt;span class=&quot;linenr&quot;&gt;2 &lt;/span&gt;&lt;span style=&quot;color: #a1db00;&quot;&gt;public&lt;/span&gt;:
&lt;span class=&quot;linenr&quot;&gt;3 &lt;/span&gt;    &lt;span style=&quot;color: #a1db00;&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span style=&quot;color: #a1db00;&quot;&gt;typename&lt;/span&gt; &lt;span style=&quot;color: #00d7af;&quot;&gt;T&lt;/span&gt;&amp;gt;              &lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;// &lt;/span&gt;&lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;see Item 3 for&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;4 &lt;/span&gt;    &lt;span style=&quot;color: #a1db00;&quot;&gt;auto&lt;/span&gt; &lt;span style=&quot;color: #a1db00;&quot;&gt;operator&lt;/span&gt; &lt;span style=&quot;color: #ffd700;&quot;&gt;()&lt;/span&gt;(&lt;span style=&quot;color: #00d7af;&quot;&gt;T&lt;/span&gt; &lt;span style=&quot;color: #ff8700;&quot;&gt;x&lt;/span&gt;) &lt;span style=&quot;color: #a1db00;&quot;&gt;const&lt;/span&gt;        &lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;// &lt;/span&gt;&lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;auto return type&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;5 &lt;/span&gt;    { &lt;span style=&quot;color: #a1db00;&quot;&gt;return&lt;/span&gt; func(&lt;span style=&quot;color: #00d7af;&quot;&gt;normalize&lt;/span&gt;(&lt;span style=&quot;color: #ff8700;&quot;&gt;x&lt;/span&gt;)); }
&lt;span class=&quot;linenr&quot;&gt;6 &lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;7 &lt;/span&gt;    ...                                &lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;// &lt;/span&gt;&lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;other closure class&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;8 &lt;/span&gt;};                                     &lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;// &lt;/span&gt;&lt;span style=&quot;color: #6c6c6c; font-style: italic;&quot;&gt;functionality&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="Effective Modern C++" scheme="http://paruka.me/categories/Translation/Effective-Modern-C/"/>
    
    
      <category term="Effective Modern C++" scheme="http://paruka.me/tags/Effective-Modern-C/"/>
    
      <category term="Press Ban" scheme="http://paruka.me/tags/Press-Ban/"/>
    
      <category term="禁止转载" scheme="http://paruka.me/tags/%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Lab 0：环境搭建</title>
    <link href="http://paruka.me/study_notes/ocw/mit/6.828/lab_0.html"/>
    <id>http://paruka.me/study_notes/ocw/mit/6.828/lab_0.html</id>
    <published>2017-07-20T10:03:00.000Z</published>
    <updated>2017-08-07T09:24:23.610Z</updated>
    
    <content type="html"><![CDATA[<div id="content">

<div id="outline-container-orgcddb736" class="outline-2">
<h2 id="简介"><a id="orgcddb736"></a>简介</h2>
<div class="outline-text-2" id="text-简介">
<p>
<a href="https://pdos.csail.mit.edu/6.828/2016/schedule.html" target="_blank" rel="external">mit 6.828</a>是一门广受好评的操作系统课程，它秉承实践为主的理念，通过设计并实现一unix-like操作系统，加深学习者对操作系统的理解。本文将遵循<a href="https://pdos.csail.mit.edu/6.828/2016/labs/lab1/" target="_blank" rel="external">Lab 1: Booting a PC</a>的指引，完成学习环境的搭建，为后续学习做好准备。
</p>

<p>
事实上，本文内容源于<a href="https://pdos.csail.mit.edu/6.828/2016/labs/lab1/" target="_blank" rel="external">Lab 1: Booting a PC</a>，本应与下一篇学习笔记一起，探讨计算机的启动流程，但因本人太懒，还是分成两篇博文讲解吧。
</p>

<p>
Lab 1是该课程的第一个练习，目的是介绍x86汇编以及PC的启动流程，因此，需要QEMU及QEMU/GDB进行协调调试。关于x86汇编相关知识，<a href="https://pdos.csail.mit.edu/6.828/2016/labs/lab1/" target="_blank" rel="external">Lab 1: Booting a PC</a>中给予了很多学习资料，在此便不再废话了，本文只会记录学习环境的搭建过程。
</p>
<a id="more"></a>
</div>
</div>

<div id="outline-container-orga7d423f" class="outline-2">
<h2 id="思路"><a id="orga7d423f"></a>思路</h2>
<div class="outline-text-2" id="text-思路">
<p>
此课程使用<a href="http://www.qemu.org/" target="_blank" rel="external">QEMU</a>模拟x86计算机，并用GDB对系统进行跟踪调试。因此，我创建了一docker镜像，于镜像中安装QEMU及GDB，并开放22端口，方便通过ssh进入容器开始调试。
</p>
</div>
</div>

<div id="outline-container-org344d6b9" class="outline-2">
<h2 id="dockerfiles"><a id="org344d6b9"></a>Dockerfiles</h2>
<div class="outline-text-2" id="text-dockerfiles">
<p>
首先当然是要下载QEMU及JOS源码了（注意，下载速度 <b>超慢</b> ，建议翻墙。）：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="linenr">1 </span>git clone git://git.qemu-project.org/qemu.git source
<span class="linenr">2 </span>git clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab
</pre>
</div>

<p>
因对debian系较为熟悉，我使用了ubuntu作为镜像，当然，国外源那 <b>超慢</b> 的下载速度是不可忍受的，因此，我基于ubuntu官方镜像制作了一自己的ubuntu镜像，镜像非常简单，仅是更换了国内<a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="external">官方源</a>并安装了supervisor而已，Dockerfile如下：
</p>

<div class="org-src-container">
<pre class="src src-dockerfile"><span class="linenr"> 1 </span># image: haruka/ubuntu
<span class="linenr"> 2 </span>
<span class="linenr"> 3 </span>FROM ubuntu
<span class="linenr"> 4 </span>MAINTAINER haruka "paruka.me@gmail.com"
<span class="linenr"> 5 </span>
<span class="linenr"> 6 </span>ADD sources.list /etc/apt/
<span class="linenr"> 7 </span>
<span class="linenr"> 8 </span>RUN apt-get update
<span class="linenr"> 9 </span>RUN apt-get upgrade -y
<span class="linenr">10 </span>
<span class="linenr">11 </span># supervisor
<span class="linenr">12 </span>RUN apt-get install -y supervisor
<span class="linenr">13 </span>RUN mkdir -p /var/log/supervisor
</pre>
</div>

<p>
除此之外，我们还需要在运行系统时，通过GDB附加进程调试，因此，容器需要运行sshd（为方便使用，密码设为111）：
</p>

<div class="org-src-container">
<pre class="src src-dockerfile"><span class="linenr"> 1 </span># image: haruka/sshd
<span class="linenr"> 2 </span>
<span class="linenr"> 3 </span>FROM haruka/ubuntu
<span class="linenr"> 4 </span>MAINTAINER haruka "paruka.me@gmail.com"
<span class="linenr"> 5 </span>
<span class="linenr"> 6 </span>RUN apt-get update
<span class="linenr"> 7 </span>RUN apt-get upgrade -y
<span class="linenr"> 8 </span>
<span class="linenr"> 9 </span># SSHD
<span class="linenr">10 </span>RUN apt-get install -y openssh-server openssh-client
<span class="linenr">11 </span>RUN mkdir /var/run/sshd
<span class="linenr">12 </span>RUN echo 'root:111' | chpasswd
<span class="linenr">13 </span>RUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
<span class="linenr">14 </span>RUN sed 's@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd
<span class="linenr">15 </span>ENV NOTVISIBLE "in users profile"
<span class="linenr">16 </span>RUN echo "export VISIBLE=now" &gt;&gt; /etc/profile
<span class="linenr">17 </span>
<span class="linenr">18 </span>
<span class="linenr">19 </span>EXPOSE 22
<span class="linenr">20 </span>CMD ["/usr/sbin/sshd", "-D"]
</pre>
</div>

<p>
接下来便是安装QEMU了：
</p>

<div class="org-src-container">
<pre class="src src-dockerfile"><span class="linenr"> 1 </span># image: haruka/qemu
<span class="linenr"> 2 </span>
<span class="linenr"> 3 </span>FROM haruka/sshd
<span class="linenr"> 4 </span>MAINTAINER haruka "paruka.me@gmail.com"
<span class="linenr"> 5 </span>
<span class="linenr"> 6 </span>RUN apt-get update
<span class="linenr"> 7 </span>RUN apt-get upgrade -y
<span class="linenr"> 8 </span>RUN apt-get install -y build-essential libtool libglib2.0-dev libpixman-1-dev zlib1g-dev git libfdt-dev gcc-multilib gdb
<span class="linenr"> 9 </span>
<span class="linenr">10 </span>RUN mkdir -p /root/qemu
<span class="linenr">11 </span>
<span class="linenr">12 </span>#source为qemu源码
<span class="linenr">13 </span>ADD source /root/qemu
<span class="linenr">14 </span>
<span class="linenr">15 </span>WORKDIR /root/qemu
<span class="linenr">16 </span>RUN ./configure
<span class="linenr">17 </span>RUN make &amp;&amp; make install
</pre>
</div>

<p>
依次进入目录，创建镜像：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="linenr">1 </span>sudo docker build -t haruka/ubuntu --rm=true .
<span class="linenr">2 </span>sudo docker build -t haruka/sshd --rm=true .
<span class="linenr">3 </span>sudo docker build -t haruka/qemu --rm=true .
</pre>
</div>

<p>
漫长的等待过后，镜像便创建完成了，通过以下命令进行实验：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="linenr">1 </span><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">/dir/to/lab/source&#20026;lab&#25152;&#22788;&#20301;&#32622;</span>
<span class="linenr">2 </span><span style="color: #6c6c6c; font-style: italic;"># </span><span style="color: #6c6c6c; font-style: italic;">git clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab</span>
<span class="linenr">3 </span>sudo docker run -d -p 10000:22 -v /dir/to/lab/source:/root/lab haruka/qemu
<span class="linenr">4 </span>ssh root@localhost -p 10000
</pre>
</div>
</div>
</div>

<div id="outline-container-org08c106c" class="outline-2">
<h2 id="容器启动脚本"><a id="org08c106c"></a>容器启动脚本</h2>
<div class="outline-text-2" id="text-容器启动脚本">
<p>
容器虽已搭建完成，但每次开始实验都需要手动开启容器、连接ssh，显得非常繁琐，因此我编写了一个脚本： <b>jos</b> ，简化这一流程：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="linenr">  1 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">!/bin/</span><span style="color: #a1db00;">bash</span>
<span class="linenr">  2 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">set -eu</span>
<span class="linenr">  3 </span>
<span class="linenr">  4 </span><span style="color: #ff8700;">LAB_DIR</span>=/home/haruka/Documents/OS/lab
<span class="linenr">  5 </span><span style="color: #ff8700;">LAB_MOUNT_TO</span>=/root/lab
<span class="linenr">  6 </span><span style="color: #ff8700;">USING_IMAGE</span>=<span style="color: #ff4ea3;">"haruka/qemu"</span>
<span class="linenr">  7 </span><span style="color: #ff8700;">CONTAINER_NAME</span>=<span style="color: #ff4ea3;">"jos"</span>
<span class="linenr">  8 </span><span style="color: #ff8700;">DEFAULT_PORT</span>=20000
<span class="linenr">  9 </span>
<span class="linenr"> 10 </span>
<span class="linenr"> 11 </span><span style="color: #a1db00;">function</span> <span style="color: #ffd700;">process_options</span>
<span class="linenr"> 12 </span>{
<span class="linenr"> 13 </span>    <span style="color: #ff8700;">i</span>=1
<span class="linenr"> 14 </span>    <span style="color: #a1db00;">while</span> [ $<span style="color: #ff8700;">i</span> -le $<span style="color: #ff8700;">#</span> ]; <span style="color: #a1db00;">do</span>
<span class="linenr"> 15 </span>        <span style="color: #a1db00;">case</span> <span style="color: #ff4ea3;">"${!i}"</span><span style="color: #a1db00;"> in</span>
<span class="linenr"> 16 </span>            -s|--startup) <span style="color: #ff8700;">startup</span>=1;;
<span class="linenr"> 17 </span>            -p|--poweroff) <span style="color: #ff8700;">poweroff</span>=1;;
<span class="linenr"> 18 </span>            -P|--port)
<span class="linenr"> 19 </span>                (( i++ ))
<span class="linenr"> 20 </span>                <span style="color: #ff8700;">port</span>=${<span style="color: #ff8700;">!</span>i}
<span class="linenr"> 21 </span>                ;;
<span class="linenr"> 22 </span>            -l|--list) <span style="color: #ff8700;">desp</span>=1;;
<span class="linenr"> 23 </span>        <span style="color: #a1db00;">esac</span>
<span class="linenr"> 24 </span>        (( i++ ))
<span class="linenr"> 25 </span>    <span style="color: #a1db00;">done</span>
<span class="linenr"> 26 </span>}
<span class="linenr"> 27 </span>
<span class="linenr"> 28 </span><span style="color: #a1db00;">function</span> <span style="color: #ffd700;">do_startup</span>
<span class="linenr"> 29 </span>{
<span class="linenr"> 30 </span>    docker run -d -p ${<span style="color: #ff8700;">1</span>}:22 -v ${<span style="color: #ff8700;">LAB_DIR</span>}:${<span style="color: #ff8700;">LAB_MOUNT_TO</span>} --name ${<span style="color: #ff8700;">CONTAINER_NAME</span>} ${<span style="color: #ff8700;">USING_IMAGE</span>}
<span class="linenr"> 31 </span>}
<span class="linenr"> 32 </span>
<span class="linenr"> 33 </span><span style="color: #a1db00;">function</span> <span style="color: #ffd700;">do_poweroff</span>
<span class="linenr"> 34 </span>{
<span class="linenr"> 35 </span>    <span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">1</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 36 </span>        docker kill ${<span style="color: #ff8700;">1</span>}
<span class="linenr"> 37 </span>        docker rm ${<span style="color: #ff8700;">1</span>}
<span class="linenr"> 38 </span>    <span style="color: #a1db00;">fi</span>
<span class="linenr"> 39 </span>}
<span class="linenr"> 40 </span>
<span class="linenr"> 41 </span><span style="color: #a1db00;">function</span> <span style="color: #ffd700;">rm_container</span>
<span class="linenr"> 42 </span>{
<span class="linenr"> 43 </span>    <span style="color: #ff8700;">ids</span>=$(docker ps -q -f <span style="color: #ff4ea3;">"status=${1}"</span> -f <span style="color: #ff4ea3;">"name=${CONTAINER_NAME}"</span>)
<span class="linenr"> 44 </span>    <span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">ids</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 45 </span>       docker rm ${<span style="color: #ff8700;">ids</span>}
<span class="linenr"> 46 </span>    <span style="color: #a1db00;">fi</span>
<span class="linenr"> 47 </span>}
<span class="linenr"> 48 </span>
<span class="linenr"> 49 </span><span style="color: #a1db00;">function</span> <span style="color: #ffd700;">do_cleanup</span>
<span class="linenr"> 50 </span>{
<span class="linenr"> 51 </span>    rm_container <span style="color: #ff4ea3;">"exited"</span>
<span class="linenr"> 52 </span>    rm_container <span style="color: #ff4ea3;">"created"</span>
<span class="linenr"> 53 </span>}
<span class="linenr"> 54 </span>
<span class="linenr"> 55 </span><span style="color: #a1db00;">function</span> <span style="color: #ffd700;">do_connect</span>
<span class="linenr"> 56 </span>{
<span class="linenr"> 57 </span>    <span style="color: #ff8700;">ssh_port</span>=$(docker port ${<span style="color: #ff8700;">CONTAINER_NAME</span>} | grep <span style="color: #ff4ea3;">"22/tcp"</span> | awk -F: <span style="color: #ff4ea3;">'{print $2}'</span>)
<span class="linenr"> 58 </span>    ssh root@localhost -p ${<span style="color: #ff8700;">ssh_port</span>}
<span class="linenr"> 59 </span>}
<span class="linenr"> 60 </span>
<span class="linenr"> 61 </span><span style="color: #ff8700;">startup</span>=
<span class="linenr"> 62 </span><span style="color: #ff8700;">poweroff</span>=
<span class="linenr"> 63 </span><span style="color: #ff8700;">port</span>=
<span class="linenr"> 64 </span><span style="color: #ff8700;">desp</span>=
<span class="linenr"> 65 </span>
<span class="linenr"> 66 </span><span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">EUID</span>} != 0 ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 67 </span>    <span style="color: #d18aff;">echo</span> <span style="color: #ff4ea3;">"Please run as root"</span>
<span class="linenr"> 68 </span>    <span style="color: #a1db00;">exit</span>
<span class="linenr"> 69 </span><span style="color: #a1db00;">fi</span>
<span class="linenr"> 70 </span>
<span class="linenr"> 71 </span>process_options $<span style="color: #ff8700;">@</span>
<span class="linenr"> 72 </span>
<span class="linenr"> 73 </span><span style="color: #ff8700;">container_id</span>=$(docker ps -q -f <span style="color: #ff4ea3;">"name=${CONTAINER_NAME}"</span>)
<span class="linenr"> 74 </span>
<span class="linenr"> 75 </span>
<span class="linenr"> 76 </span><span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">poweroff</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 77 </span>    <span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">container_id</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 78 </span>        do_poweroff ${<span style="color: #ff8700;">container_id</span>}
<span class="linenr"> 79 </span>    <span style="color: #a1db00;">fi</span>
<span class="linenr"> 80 </span>
<span class="linenr"> 81 </span>    do_cleanup
<span class="linenr"> 82 </span>    <span style="color: #a1db00;">exit</span>
<span class="linenr"> 83 </span><span style="color: #a1db00;">fi</span>
<span class="linenr"> 84 </span>
<span class="linenr"> 85 </span><span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">desp</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 86 </span>    <span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">container_id</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 87 </span>        <span style="color: #d18aff;">echo</span> <span style="color: #ff4ea3;">"container is running!"</span>
<span class="linenr"> 88 </span>        <span style="color: #d18aff;">echo</span> <span style="color: #ff4ea3;">"container id: ${container_id}"</span>
<span class="linenr"> 89 </span>        docker port ${<span style="color: #ff8700;">CONTAINER_NAME</span>}
<span class="linenr"> 90 </span>        <span style="color: #a1db00;">exit</span>
<span class="linenr"> 91 </span>    <span style="color: #a1db00;">fi</span>
<span class="linenr"> 92 </span>
<span class="linenr"> 93 </span>    <span style="color: #a1db00;">if</span> [ $(docker ps -q -f <span style="color: #ff4ea3;">"status=exited"</span> -f <span style="color: #ff4ea3;">"name=${CONTAINER_NAME}"</span>) ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 94 </span>        <span style="color: #d18aff;">echo</span> <span style="color: #ff4ea3;">"container exited, run: \"sudo jos -p\" to cleanup"</span>
<span class="linenr"> 95 </span>        <span style="color: #a1db00;">exit</span>
<span class="linenr"> 96 </span>    <span style="color: #a1db00;">fi</span>
<span class="linenr"> 97 </span>
<span class="linenr"> 98 </span>    <span style="color: #a1db00;">if</span> [ $(docker ps -q -f <span style="color: #ff4ea3;">"status=created"</span> -f <span style="color: #ff4ea3;">"name=${CONTAINER_NAME}"</span>) ]; <span style="color: #a1db00;">then</span>
<span class="linenr"> 99 </span>        <span style="color: #d18aff;">echo</span> <span style="color: #ff4ea3;">"container created, run: \"sudo jos -p\" to cleanup"</span>
<span class="linenr">100 </span>        <span style="color: #a1db00;">exit</span>
<span class="linenr">101 </span>    <span style="color: #a1db00;">fi</span>
<span class="linenr">102 </span>
<span class="linenr">103 </span>    <span style="color: #d18aff;">echo</span> <span style="color: #ff4ea3;">"no container is running"</span>
<span class="linenr">104 </span>    <span style="color: #a1db00;">exit</span>
<span class="linenr">105 </span><span style="color: #a1db00;">fi</span>
<span class="linenr">106 </span>
<span class="linenr">107 </span><span style="color: #a1db00;">if</span> [ <span style="color: #ff4b4b;">!</span> ${<span style="color: #ff8700;">container_id</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr">108 </span>    do_cleanup
<span class="linenr">109 </span>    do_startup ${<span style="color: #ff8700;">port</span>:-$<span style="color: #ff8700;">DEFAULT_PORT</span>}
<span class="linenr">110 </span><span style="color: #a1db00;">fi</span>
<span class="linenr">111 </span>
<span class="linenr">112 </span><span style="color: #a1db00;">if</span> [ ${<span style="color: #ff8700;">startup</span>} ]; <span style="color: #a1db00;">then</span>
<span class="linenr">113 </span>    <span style="color: #a1db00;">exit</span>
<span class="linenr">114 </span><span style="color: #a1db00;">fi</span>
<span class="linenr">115 </span>
<span class="linenr">116 </span>do_connect
</pre>
</div>

<p>
执行脚本时，默认行为为：
</p>

<ul class="org-ul">
<li>若容器未运行，则运行容器</li>
<li>使用ssh连接容器</li>
</ul>

<p>
因此，将脚本目录加入环境变量，开始实验就变得非常简单了：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="linenr"> 1 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">&#25171;&#24320;&#19968;&#32456;&#31471;&#65292;&#24320;&#22987;&#23454;&#39564;</span>
<span class="linenr"> 2 </span>sudo jos
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">&#20197;&#35843;&#35797;&#27169;&#24335;&#36816;&#34892;jos</span>
<span class="linenr"> 5 </span>make qemu-gdb
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">&#24320;&#21551;&#21478;&#19968;&#32456;&#31471;&#65292;&#36830;&#20837;&#23481;&#22120;</span>
<span class="linenr"> 8 </span>sudo jos
<span class="linenr"> 9 </span>
<span class="linenr">10 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">gdb&#38468;&#21152;jos&#65292;&#24320;&#22987;&#21333;&#27493;&#35843;&#35797;</span>
<span class="linenr">11 </span>make gdb
<span class="linenr">12 </span>
<span class="linenr">13 </span><span style="color: #6c6c6c; font-style: italic;">#</span><span style="color: #6c6c6c; font-style: italic;">&#20851;&#38381;&#23481;&#22120;</span>
<span class="linenr">14 </span>sudo jos -p
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-07 Mon 17:24</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;

&lt;div id=&quot;outline-container-orgcddb736&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a id=&quot;orgcddb736&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-简介&quot;&gt;
&lt;p&gt;
&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2016/schedule.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mit 6.828&lt;/a&gt;是一门广受好评的操作系统课程，它秉承实践为主的理念，通过设计并实现一unix-like操作系统，加深学习者对操作系统的理解。本文将遵循&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2016/labs/lab1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lab 1: Booting a PC&lt;/a&gt;的指引，完成学习环境的搭建，为后续学习做好准备。
&lt;/p&gt;

&lt;p&gt;
事实上，本文内容源于&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2016/labs/lab1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lab 1: Booting a PC&lt;/a&gt;，本应与下一篇学习笔记一起，探讨计算机的启动流程，但因本人太懒，还是分成两篇博文讲解吧。
&lt;/p&gt;

&lt;p&gt;
Lab 1是该课程的第一个练习，目的是介绍x86汇编以及PC的启动流程，因此，需要QEMU及QEMU/GDB进行协调调试。关于x86汇编相关知识，&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2016/labs/lab1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Lab 1: Booting a PC&lt;/a&gt;中给予了很多学习资料，在此便不再废话了，本文只会记录学习环境的搭建过程。
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Study Notes" scheme="http://paruka.me/categories/Study-Notes/"/>
    
      <category term="OS" scheme="http://paruka.me/categories/Study-Notes/OS/"/>
    
    
      <category term="mit 6.828" scheme="http://paruka.me/tags/mit-6-828/"/>
    
  </entry>
  
  <entry>
    <title>条款24：区别通用引用与右值引用</title>
    <link href="http://paruka.me/translation/effective_modern_cpp/item24.html"/>
    <id>http://paruka.me/translation/effective_modern_cpp/item24.html</id>
    <published>2017-07-10T07:22:00.000Z</published>
    <updated>2017-08-07T06:09:51.713Z</updated>
    
    <content type="html"><![CDATA[<div id="content">
<p>
都说真理让人如获自由，但在正确的情形下，一个恰当的谎言却能产生同样的效果。此条款便是一个这样的谎言。不过，我们是在与软件打交道，因此，应避免使用"谎言"这样的敏感词汇，故用"抽象"一词取而代之。
</p>

<p>
你使用 <b>T&amp;&amp;</b> 的方式来声明一右值引用。因此，假定代码中看到的"T&amp;&amp;"为右值引用，似乎合乎情理。哎，可惜它并非如此简单。
</p>

<a id="more"></a>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">param</span>);           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rvalue reference</span>
<span class="linenr"> 2 </span>
<span class="linenr"> 3 </span><span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">val1</span> = Widget();         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rvalue reference</span>
<span class="linenr"> 4 </span>
<span class="linenr"> 5 </span><span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">var2</span> = val1;               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">not rvalue reference</span>
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 8 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">T</span>&gt;&amp;&amp; <span style="color: #ff8700;">param</span>);   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rvalue reference</span>
<span class="linenr"> 9 </span>
<span class="linenr">10 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">11 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>);                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">not rvalue reference</span>
</pre>
</div>

<p>
事实上，"T&amp;&amp;"有两个不同的含义。其一当然就是右值引用。这种引用类型表现的与你期望的完全一致：它们只能绑定至右值，主要的存在目的<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>为标识那些能移动的对象。
</p>

<p>
"T&amp;&amp;"的另一个含义既不是右值引用，也不是左值引用，这种引用在代码中看起来像是右值引用（"T&amp;&amp;"），却可以表现出左值引用的行为（"T&amp;"）。这种双重性允许它们既能绑定右值（像右值引用）也能绑定左值（像左值引用），而且还能绑定至 <b>const</b> 、 <b>non-const</b> 、 <b>volatile</b> 、 <b>non-volatile</b> 属性的对象，即使它们同时拥有 <b>const</b> 和 <b>volatile</b> 属性也毫不例外（可以绑定），实际上，它们可以绑定至任何对象。这种空前复杂的引用应当被赋予一专属名字。我称之为 <b>通用引用（universal references）<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></b> 。
</p>

<p>
通用引用于两种情境中出现。最常见的情境为模板函数的参数。正如之前所列例子中引出的如下代码：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>);                 <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is a universal reference</span>
</pre>
</div>

<p>
第二种情境便是 <b>auto</b> 声明，以下例子同样引用自之前所列示例：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">var2</span> = var1;                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">var2 is a universal reference</span>
</pre>
</div>

<p>
这些情境的共通点便是 <b>类型推导</b> 。对于模板函数f， <b>param</b> 的类型会被推导，var2的声明同样如此，他的类型一样会被推导。与如下例子对比（同样引自之前所列示例），它们缺乏类型推导。因此，当你发现"T&amp;&amp;"没有类型推导，它便是右值引用：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">param</span>);             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">no type deduction;</span>
<span class="linenr">2 </span>                                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is an rvalue reference</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span><span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">var1</span> = Widget();           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">no type deduction;</span>
<span class="linenr">5 </span>                                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">var1 is an rvalue reference</span>
</pre>
</div>

<p>
通用引用也是引用，因此，它们必须被初始化。通用引用的初始值决定了它应表现为右值引用或是左值引用。如果初始值为右值，通用引用相当与一右值引用。如果初始值为左值，它便相当于一左值引用。对于模板参数中的通用引用，它的初始化由调用端提供：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>);                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is a universal reference</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span><span style="color: #00d7af;">Widget</span> <span style="color: #ff8700;">w</span>;
<span class="linenr">5 </span>f(w);                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">lvalue passed to f; param's type is</span>
<span class="linenr">6 </span>                                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Widget&amp; (i.e., an lvalue reference)</span>
<span class="linenr">7 </span>
<span class="linenr">8 </span>f(<span style="color: #5fafd7;">std</span>::move(w));                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rvalue passed to f; param's type is</span>
<span class="linenr">9 </span>                                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Widget&amp;&amp; (i.e., an rvalue reference)</span>
</pre>
</div>

<p>
对于（成为）通用引用，类型推导是必须的，却并不足够。其引用声明形式必须正确，声明样式非常固定，必须为精确的"T&amp;&amp;"样式。参看引自之前例子的代码：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">T</span>&gt;&amp;&amp; <span style="color: #ff8700;">param</span>);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is an rvalue reference</span>
</pre>
</div>

<p>
当f被调用，类型 <b>T</b> 会被推导（除非调用者直接指定，这种边缘情况我们并不关心）。但 <b>param</b> 的类型声明并不是"T&amp;&amp;"，而是"std::vector&lt;T&gt;&amp;&amp;"，它并不满足通用引用的声明规则。因此， <b>param</b> 为右值引用，如果你试图向 <b>f</b> 传入一左值，编译器将很乐于向你证明这点：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">int</span>&gt; <span style="color: #ff8700;">v</span>;
<span class="linenr">2 </span>f(v);                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">error! can't bind lvalue to</span>
<span class="linenr">3 </span>                                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rvalue reference</span>
</pre>
</div>

<p>
哪怕是一小小的 <b>const</b> 修饰符，也足以让它失去成为通用引用的资格：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>);             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is an rvalue reference</span>
</pre>
</div>

<p>
于模板函数中看到 <b>T&amp;&amp;</b> 类型的参数时，你可能会认为它是一个通用引用。但这并不总是正确，因为模板并不能保证类型推导的发生。考虑 <b>std::vector</b> 的 <b>push_back</b> 成员函数：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">T</span>, <span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Allocator</span> = <span style="color: #00d7af;">allocator</span>&lt;<span style="color: #00d7af;">T</span>&gt;&gt;    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from C++</span>
<span class="linenr">2 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">vector</span>{                                         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Standards</span>
<span class="linenr">3 </span>    <span style="color: #00d7af;">void</span> <span style="color: #ffd700;">push_back</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">x</span>);
<span class="linenr">4 </span>    ...
<span class="linenr">5 </span>}
</pre>
</div>

<p>
<b>push_back</b> 的参数完全符合通用引用的声明样式，但却没有发生类型推导。这是因为 <b>push_back</b> 是作为 <b>vector</b> 实例化后的一部分存在的，而这个实例化已经完全确定了 <b>push_back</b> 的声明，也就是说：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;Widget&gt; <span style="color: #ff8700;">v</span>;
</pre>
</div>

<p>
会使 <b>std::vector</b> 实例化为如下样式：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Vector</span>&lt;Widget, <span style="color: #00d7af;">allocator</span>&lt;Widget&gt;&gt;
<span class="linenr">2 </span>{
<span class="linenr">3 </span><span style="color: #a1db00;">public</span>:
<span class="linenr">4 </span>    <span style="color: #00d7af;">void</span> <span style="color: #ffd700;">push_back</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">x</span>);                       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rvalue reference</span>
<span class="linenr">5 </span>}
</pre>
</div>

<p>
现在你可以很清楚的看到， <b>push_back</b> 并没有触发类型推导。 <b>std::vector</b> 的 <b>push_back</b> 方法（有两个──函数重载）总是声明了一个 <b>T</b> 类型的右值引用作为参数。相反，与其功能类似的另一成员函数 <b>emplace_back</b> 则触发了类型推导：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">class</span> <span style="color: #00d7af;">T</span>, <span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Allocator</span> = <span style="color: #00d7af;">allocator</span>&lt;<span style="color: #00d7af;">T</span>&gt;&gt;    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">still from</span>
<span class="linenr">2 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">vector</span> {                                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">C++</span>
<span class="linenr">3 </span><span style="color: #a1db00;">public</span>:                                               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Standards</span>
<span class="linenr">4 </span>    <span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">class</span>... Args&gt;
<span class="linenr">5 </span>    <span style="color: #00d7af;">void</span> <span style="color: #ffd700;">emplace_back</span>(<span style="color: #00d7af;">Args</span>&amp;&amp;... args);
<span class="linenr">6 </span>    ...
<span class="linenr">7 </span>}
</pre>
</div>

<p>
这里的类型参数 <b>Args</b> 与 <b>vector</b> 的类型参数独立，因此每次 <b>emplace_back</b> 调用的时候都会发生类型推导。（好吧，其实 <b>Args</b> 是一个参数包，不是一具体的参数类型，但为了更好的讨论这一话题，我们可以视其为一类型参数）。
</p>

<p>
事实上， <b>emplace_back</b> 的类型参数为 <b>Args</b> ，是一个通用引用，这一事实巩固了我之前所述的观点：通用引用的声明样式必须为"T&amp;&amp;"，但并没有对名字 <b>T</b> 的使用有要求。例如如下模板函数便接收一通用引用类型的参数，它的声明样式（"type&amp;&amp;"）正确，且参数类型需要推导（再次强调：需排除调用者显示指定类型的极端情况）：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span> &lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">MyTemplateType</span>&gt;          <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is a</span>
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">someFunc</span>(<span style="color: #00d7af;">MyTemplateType</span>&amp;&amp; <span style="color: #ff8700;">param</span>);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">universal reference</span>
</pre>
</div>

<p>
我之前讲过， <b>auto</b> 类型的变量也可以是通用引用。更精确的说，声明为 <b>auto&amp;&amp;</b> 类型的变量就是通用引用，因为它满足通用引用样式（"T&amp;&amp;"）且触发了类型推导。 <b>auto</b> 通用引用并不像模板参数中的通用引用那么常见，它们在 <b>C++11</b> 中偶有出现，于 <b>C++14</b> 中变得更加频繁，因为 <b>C++14</b> 允许在 <b>lambda</b> 表达式中使用 <b>auto&amp;&amp;</b> 声明参数。例如，在 <b>C++14</b> 中，如果你想编写一 <b>lambda</b> 表达式以记录任一函数的调用耗时，你可以这样编写：
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">timeFuncInvocation</span> =
<span class="linenr">2 </span>    [](<span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">func</span>, <span style="color: #a1db00;">auto</span>&amp;&amp;... params)                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">C++14</span>
<span class="linenr">3 </span>    {
<span class="linenr">4 </span>        <span style="color: #00d7af;">start</span> <span style="color: #ff8700;">timer</span>;
<span class="linenr">5 </span>        <span style="color: #5fafd7;">std</span>::forward&lt;<span style="color: #a1db00;">decltype</span>(func)&gt;(func)(            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">invoke func</span>
<span class="linenr">6 </span>            <span style="color: #5fafd7;">std</span>::forward&lt;<span style="color: #a1db00;">decltype</span>(params)&gt;(params)...  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">on params</span>
<span class="linenr">7 </span>        );
<span class="linenr">8 </span>        <span style="color: #00d7af;">stop</span> <span style="color: #ff8700;">timer</span> <span style="color: #a1db00;">and</span> record elapsed time;
<span class="linenr">9 </span>    };
</pre>
</div>

<p>
如果你对"<b>std::forward&lt;decltype(blah blah blah)&gt;</b>"的反应是"誒？！"，那就说明你尚未阅读<a href="./item33.html">条款33</a>，不过不用担心。这里关注的重点是 <b>lambda</b> 中的 <b>auto&amp;&amp;</b> 声明的参数。 <b>func</b> 是一个可绑定至任一可调用对象的通用引用，不论左值或右值。 <b>args</b> 是零个或多个通用引用（一个通用引用参数包），它可以绑定任意个数任何类型的对象。结果就是，拜 <b>auto</b> 通用引用所赐， <b>timeFuncInvocation</b> 可以计算几乎所有函数的执行耗时。（关于"任意"和"几乎所有"的区别，请参看<a href="./item30.html">条款30</a>。）
</p>

<p>
记住，此条款 ──通用引用的基础── 是个谎言&#x2026;呃，应该叫"抽象"。隐含其中的真相是引用折叠，既<a href="./item28.html">条款28</a>的主题。但这一真相并没有减少此抽象的用处。区分右值引用与通用引用能帮助你更精确的阅读代码（"这里的 <b>T&amp;&amp;</b> 只能绑定到右值？还是都能绑定？"），也能让你与同事的交流更加顺畅（"在这里我使用的是通用引用，不是右值引用&#x2026;&#x2026;"）。也将使你更易理解<a href="./item25.html">条款25</a>与<a href="./item26.html">条款26</a>，它们都依赖于这一区分。所以，拥抱它吧。并陶醉其中。正如牛顿运动定律（实际上是不正确的），它通常比爱因斯坦的广义相对论（"真相"）更为有用、简单，因此，通用引用的概念通常比它的细节──引用折叠更为可取。
</p>

<div id="outline-container-org1b607ae" class="outline-2">
<h2 id="记住"><a id="org1b607ae"></a>记住</h2>
<div class="outline-text-2" id="text-记住">
<ul class="org-ul">
<li>如果一个模板函数的参数是 <b>T&amp;&amp;</b> ，且 <b>T</b> 需要被推导，或者一个对象被声明为 <b>auto&amp;&amp;</b> ，那么该参数或此对象为通用引用。</li>
<li>如果类型声明并未满足严格的 <b>type&amp;&amp;</b> 样式，或者没有发生类型推导， <b>type&amp;&amp;</b> 表示一个右值引用。</li>
<li>通用引用在使用右值初始化时相当于一右值引用。在使用左值初始化时相当于一左值引用。</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
法语：raison d'être
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="./item25.html">条款25</a>会告诉你：通用引用几乎都要配合 <b>std::forward</b> 使用，因此此书即将出版时，许多C++标准委员会的成员开始称 <b>universal references</b> 为 <b>forwarding references</b> 。
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-07 Mon 14:22</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;
&lt;p&gt;
都说真理让人如获自由，但在正确的情形下，一个恰当的谎言却能产生同样的效果。此条款便是一个这样的谎言。不过，我们是在与软件打交道，因此，应避免使用&quot;谎言&quot;这样的敏感词汇，故用&quot;抽象&quot;一词取而代之。
&lt;/p&gt;

&lt;p&gt;
你使用 &lt;b&gt;T&amp;amp;&amp;amp;&lt;/b&gt; 的方式来声明一右值引用。因此，假定代码中看到的&quot;T&amp;amp;&amp;amp;&quot;为右值引用，似乎合乎情理。哎，可惜它并非如此简单。
&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="Effective Modern C++" scheme="http://paruka.me/categories/Translation/Effective-Modern-C/"/>
    
    
      <category term="Effective Modern C++" scheme="http://paruka.me/tags/Effective-Modern-C/"/>
    
      <category term="Press Ban" scheme="http://paruka.me/tags/Press-Ban/"/>
    
      <category term="禁止转载" scheme="http://paruka.me/tags/%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Copy elision</title>
    <link href="http://paruka.me/translation/cppreference/copy_elision.html"/>
    <id>http://paruka.me/translation/cppreference/copy_elision.html</id>
    <published>2017-07-10T04:38:00.000Z</published>
    <updated>2017-08-06T18:37:33.365Z</updated>
    
    <content type="html"><![CDATA[<div id="content">
<p>
翻译至<a href="http://en.cppreference.com/w/cpp/language/copy_elision" target="_blank" rel="external">cppreference</a>。
</p>

<p>
优化了拷贝及移动(since C++11)构造函数，提供值传递的零拷贝语义。
</p>

<div id="outline-container-orge82ac14" class="outline-2">
<h2 id="解释"><a id="orge82ac14"></a>解释</h2>
<div class="outline-text-2" id="text-解释">
<p>
在以下情况，编译器必须省略拷贝及复制构造函数的调用，即便该对象的拷贝/复制构造函数和析构函数有明显的副作用。
</p>
<a id="more"></a>

<ul class="org-ul">
<li>初始化时，若初始化语句是一个prvalue且它的cv-unqualified类型与目标的类型相同，该初始化语句将直接用于初始化目标对象。</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">T</span> <span style="color: #ff8700;">x</span> = T(<span style="color: #ffd700;">T</span>(<span style="color: #00d7af;">T</span>())); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#21482;&#20250;&#35843;&#29992;&#19968;&#27425;T&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
</pre>
</div>

<ul class="org-ul">
<li>在函数调用中，函数返回语句的操作数是一个prvalue，且与该函数的返回值类型相同。</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">T</span> <span style="color: #ffd700;">f</span>() { <span style="color: #a1db00;">return</span> T{}; }
<span class="linenr">2 </span><span style="color: #00d7af;">T</span> <span style="color: #ff8700;">x</span> = f();           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#21482;&#20250;&#35843;&#29992;&#19968;&#27425;T&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
<span class="linenr">3 </span><span style="color: #00d7af;">T</span>* <span style="color: #ff8700;">p</span> = <span style="color: #a1db00;">new</span> <span style="color: #00d7af;">T</span>(f());   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#21482;&#20250;&#35843;&#29992;&#19968;&#27425;T&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;</span>
</pre>
</div>

<p>
在以下情况，允许编译器省略拷贝及复制构造函数的调用，即便该对象的拷贝/复制构造函数和析构函数有明显的副作用。
</p>

<ul class="org-ul">
<li>函数以值方式返回一个对象，且返回语句的表达式是一个拥有自动存储期<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>的non-volatile对象，它不能是该函数的参数或catch语句的参数，其类型（忽略最高层的cv-qualification）必须与函数返回值类型一致，此时拷贝/复制函数会被忽略（since C++11）。该临时对象将直接于函数调用处构造（拷贝或移动）。这种类型的禁止拷贝行为，我们称其为NRVO，"named return value optimization"。</li>
<li>一个未绑定至任何引用的无名临时变量，会被移动（Since C++11）或拷贝至同类型的其他对象(忽略最高层的cv-qualification)，此时复制/移动（Since C++11）会被忽略。此临时变量会在函数调用处构造（拷贝或移动）。当该无名临时对象是函数的返回值时，这种类型的拷贝禁止行为被称为RVO，"return value optimization"。(until C++17)</li>
</ul>

<p>
<b>以上优化所有编译器必须实现。(since C++17)</b>
</p>

<ul class="org-ul">
<li>（since C++11）在一个异常抛出语句中，如果操作数是一个拥有自动存储期的non-volatile对象，它不能是函数的参数或catch语句的参数，且生命期没有跨越最里层的try语句块（如果有），此时，拷贝/移动会被忽略。该临时变量将直接于异常对象捕获处构造（拷贝或移动）。</li>
<li>（since C++11）处理异常时，如果catch语句的参数类型与抛出的异常对象的类型一致（忽略最高层的cv-qualification），拷贝会被忽略，catch子句将直接访问该异常对象，正如被引用一般。在可能改变程序行为的情况下（非忽略拷贝构造函数及析构函数的调用），该优化不会生效（例如：catch子句的参数被修改，并将该异常对象通过*throw*语句重新抛出）。</li>
</ul>

<p>
当 <b>copy elision</b> 发生时，拷贝/ <b>移动（since C++11）</b> 操作的省略，是通过将目标及源对象视为同一对象的两个不同引用实现的，它的析构并不会被省略，只会推迟至两个对象均已销毁时发生 <b>（除非目标对象是通过其右值引用版本的构造函数创建的，这种情况下，析构将发生在目标对象销毁时）(since C++17)</b> 。
</p>

<p>
<b>copy elision</b> 可以嵌套触发以消除多重拷贝。
</p>

<ul class="org-ul">
<li>在<a href="http://en.cppreference.com/w/cpp/language/constant_expression" target="_blank" rel="external">常量表达式</a>及<a href="http://en.cppreference.com/w/cpp/language/constant_initialization" target="_blank" rel="external">常量初始化语句</a>中，所有满足 <b>copy elision</b> 的地方都会触发(graranteed)（by post-C++14 defect report CWG 2022）:</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">since c++14</span>
<span class="linenr"> 2 </span>
<span class="linenr"> 3 </span><span style="color: #a1db00;">struct</span> <span style="color: #00d7af;">A</span> {
<span class="linenr"> 4 </span>    <span style="color: #00d7af;">void</span> *<span style="color: #ff8700;">p</span>;
<span class="linenr"> 5 </span>    <span style="color: #a1db00;">constexpr</span> <span style="color: #00d7af;">A</span>(): <span style="color: #ff8700;">p</span>(<span style="color: #a1db00;">this</span>) {}
<span class="linenr"> 6 </span>};
<span class="linenr"> 7 </span>
<span class="linenr"> 8 </span><span style="color: #a1db00;">constexpr</span> <span style="color: #00d7af;">A</span> <span style="color: #ffd700;">g</span>() {
<span class="linenr"> 9 </span>  <span style="color: #00d7af;">A</span> <span style="color: #ff8700;">a</span>;
<span class="linenr">10 </span>  <span style="color: #a1db00;">return</span> a;
<span class="linenr">11 </span>}
<span class="linenr">12 </span>
<span class="linenr">13 </span><span style="color: #a1db00;">constexpr</span> <span style="color: #00d7af;">A</span> <span style="color: #ff8700;">a</span>;        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">a.p points to a</span>
<span class="linenr">14 </span><span style="color: #a1db00;">constexpr</span> <span style="color: #00d7af;">A</span> <span style="color: #ff8700;">b</span> = g();  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">b.p points to b (NRVO guaranteed)</span>
<span class="linenr">15 </span>
<span class="linenr">16 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">g</span>() {
<span class="linenr">17 </span>  <span style="color: #00d7af;">A</span> <span style="color: #ff8700;">c</span> = g();          <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">c.p may point to c or to an ephemeral temporary</span>
<span class="linenr">18 </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc9cc29" class="outline-2">
<h2 id="注意"><a id="orgdc9cc29"></a>注意</h2>
<div class="outline-text-2" id="text-注意">
<p>
<b>Copy elision</b> 是 <b>唯一一种标准允许的优化策略(until C++14)</b> ， <b>C++14还引入了另一种优化：<a href="http://en.cppreference.com/w/cpp/language/new#Allocation" target="_blank" rel="external">allocation elision and extension</a></b> ，它可能触发显著的副作用。因为一些编译器并不会在所有满足条件的地方触发copy elision(例如：调试模式)，那些依赖于拷贝／移动构造函数及析构函数副作用的程序将不可移植。
</p>

<p>
在 <b>return语句</b> 或 <b>throw语句</b> 中，如果编译器无法对满足条件的地方执行copy elision，且源目标不是函数参数，编译器将试图使用移动构造函数，即便该对象是左值；详情请看<a href="http://en.cppreference.com/w/cpp/language/return#Notes" target="_blank" rel="external">return statement</a>。
</p>
</div>
</div>

<div id="outline-container-org8a301fa" class="outline-2">
<h2 id="例子"><a id="org8a301fa"></a>例子</h2>
<div class="outline-text-2" id="text-例子">
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #d18aff;">#include</span> <span style="color: #ff4ea3;">&lt;iostream&gt;</span>
<span class="linenr"> 2 </span><span style="color: #d18aff;">#include</span> <span style="color: #ff4ea3;">&lt;vector&gt;</span>
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #a1db00;">struct</span> <span style="color: #00d7af;">Noisy</span>
<span class="linenr"> 5 </span>{
<span class="linenr"> 6 </span>    <span style="color: #ffd700;">Noisy</span>() { <span style="color: #5fafd7;">std</span>::cout &lt;&lt; <span style="color: #ff4ea3;">"constructed\n"</span>; }
<span class="linenr"> 7 </span>    <span style="color: #ffd700;">Noisy</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">Noisy</span>&amp;) { <span style="color: #5fafd7;">std</span>::cout &lt;&lt; <span style="color: #ff4ea3;">"copy-constructed\n"</span>; }
<span class="linenr"> 8 </span>    <span style="color: #ffd700;">Noisy</span>(<span style="color: #00d7af;">Noisy</span>&amp;&amp;) { <span style="color: #5fafd7;">std</span>::cout &lt;&lt; <span style="color: #ff4ea3;">"move-constructed\n"</span>; }
<span class="linenr"> 9 </span>    ~<span style="color: #ffd700;">Noisy</span>() { <span style="color: #5fafd7;">std</span>::cout &lt;&lt; <span style="color: #ff4ea3;">"destructed\n"</span>; }
<span class="linenr">10 </span>};
<span class="linenr">11 </span>
<span class="linenr">12 </span><span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">Noisy</span>&gt; <span style="color: #ffd700;">f</span>()
<span class="linenr">13 </span>{
<span class="linenr">14 </span>    <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">Noisy</span>&gt; <span style="color: #ff8700;">v</span> = <span style="color: #5fafd7;">std</span>::vector&lt;<span style="color: #00d7af;">Noisy</span>&gt;(3); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">copy elision when initializing v</span>
<span class="linenr">15 </span>                                                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from a temporary (until C++17)</span>
<span class="linenr">16 </span>                                                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from a prvalue (since C++17)</span>
<span class="linenr">17 </span>    <span style="color: #a1db00;">return</span> v; <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">NRVO from v to the result object (not guaranteed in C++17)</span>
<span class="linenr">18 </span>}             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">if optimization is disabled, the move constructor is called</span>
<span class="linenr">19 </span>
<span class="linenr">20 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">g</span>(<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">Noisy</span>&gt; <span style="color: #ff8700;">arg</span>)
<span class="linenr">21 </span>{
<span class="linenr">22 </span>    <span style="color: #5fafd7;">std</span>::cout &lt;&lt; <span style="color: #ff4ea3;">"arg.size() = "</span> &lt;&lt; arg.size() &lt;&lt; <span style="color: #ff4ea3;">'\n'</span>;
<span class="linenr">23 </span>}
<span class="linenr">24 </span>
<span class="linenr">25 </span><span style="color: #00d7af;">int</span> <span style="color: #ffd700;">main</span>()
<span class="linenr">26 </span>{
<span class="linenr">27 </span>    <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">Noisy</span>&gt; <span style="color: #ff8700;">v</span> = f(); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">copy elision in initialization of v</span>
<span class="linenr">28 </span>                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from the temporary returned by f() (until C++17)</span>
<span class="linenr">29 </span>                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from the prvalue f() (since C++17)</span>
<span class="linenr">30 </span>    g(f());                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">copy elision in initialization of the parameter of g()</span>
<span class="linenr">31 </span>                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from the temporary returned by f() (until C++17)</span>
<span class="linenr">32 </span>                                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">from the prvalue f() (since C++17)</span>
<span class="linenr">33 </span>}
</pre>
</div>

<p>
可能的输出：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span>constructed
<span class="linenr"> 2 </span>constructed
<span class="linenr"> 3 </span>constructed
<span class="linenr"> 4 </span>constructed
<span class="linenr"> 5 </span>constructed
<span class="linenr"> 6 </span><span style="color: #00d7af;">constructed</span>
<span class="linenr"> 7 </span><span style="color: #ffd700;">arg</span>.size() = 3
<span class="linenr"> 8 </span>destructed
<span class="linenr"> 9 </span>destructed
<span class="linenr">10 </span>destructed
<span class="linenr">11 </span>destructed
<span class="linenr">12 </span>destructed
<span class="linenr">13 </span>destructed
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf06789b" class="outline-2">
<h2 id="缺陷"><a id="orgf06789b"></a>缺陷</h2>
<div class="outline-text-2" id="text-缺陷">
<p>
以下缺陷报表(defect reports)追溯到之前的C++标准。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left">

<col class="org-left">

<col class="org-left">

<col class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">DR</th>
<th scope="col" class="org-left">Applied to</th>
<th scope="col" class="org-left">Behavior as published</th>
<th scope="col" class="org-left">Correct behavior</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#2022" target="_blank" rel="external">CWG 2022</a></td>
<td class="org-left">C++14</td>
<td class="org-left">copy elision was optional in constant expressions</td>
<td class="org-left">copy elision mandatory</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd409a4c" class="outline-2">
<h2 id="参阅"><a id="orgd409a4c"></a>参阅</h2>
<div class="outline-text-2" id="text-参阅">
<ul class="org-ul">
<li><a href="http://en.cppreference.com/w/cpp/language/copy_initialization" target="_blank" rel="external">copy initialization</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/copy_constructor" target="_blank" rel="external">copy constructor</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/move_constructor" target="_blank" rel="external">move constructor</a></li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
automatic storage duration
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-07 Mon 14:22</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;
&lt;p&gt;
翻译至&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_elision&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cppreference&lt;/a&gt;。
&lt;/p&gt;

&lt;p&gt;
优化了拷贝及移动(since C++11)构造函数，提供值传递的零拷贝语义。
&lt;/p&gt;

&lt;div id=&quot;outline-container-orge82ac14&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;解释&quot;&gt;&lt;a id=&quot;orge82ac14&quot;&gt;&lt;/a&gt;解释&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-解释&quot;&gt;
&lt;p&gt;
在以下情况，编译器必须省略拷贝及复制构造函数的调用，即便该对象的拷贝/复制构造函数和析构函数有明显的副作用。
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="cppreference" scheme="http://paruka.me/categories/Translation/cppreference/"/>
    
    
      <category term="cppreference" scheme="http://paruka.me/tags/cppreference/"/>
    
  </entry>
  
  <entry>
    <title>条款23：理解std::move和std::forward</title>
    <link href="http://paruka.me/translation/effective_modern_cpp/item23.html"/>
    <id>http://paruka.me/translation/effective_modern_cpp/item23.html</id>
    <published>2017-03-05T17:17:00.000Z</published>
    <updated>2017-08-30T08:02:20.867Z</updated>
    
    <content type="html"><![CDATA[<div id="content">

<div id="outline-container-orgdc926b6" class="outline-2">
<h2 id="第五章-右值引用移动语义及完美转发"><a id="orgdc926b6"></a>第五章 右值引用、移动语义及完美转发</h2>
<div class="outline-text-2" id="text-第五章-右值引用移动语义及完美转发">
<p>
当你初次学习它们时，移动语义和完美转发看起来非常直白：
</p>
<ul class="org-ul">
<li><b>移动语义</b> 让编译器将代价高昂的拷贝操作替换为相对低廉的移动操作。正如其名，拷贝构造函数及拷贝赋值函数给予你控制对象复制的能力，与此类似，移动构造函数和移动赋值函数则给予你控制移动语义的能力。移动语义还允许你创建move-only类型的对象，例如： <b>std::unique_ptr</b> 、 <b>std::future</b> 和 <b>std::thread</b> 。</li>
<li><b>完美转发</b> 使我们可以将模板函数的实参（任意修饰符的实参）转发给另一函数。</li>
</ul>
<p>
右值引用是这两个迥异特性的粘合剂。它们是构成移动语义及完美转发的基石。
</p>
<a id="more"></a>

<p>
随着对这些特性的深入理解，你将更加意识到，你对它们一开始的印象，只不过是冰山一角。它们（移动语义、完美转发和右值引用）比呈现出来的（样子）更加微妙。比如： <b>std::move</b> 并不移动任何东西，完美转发也并不完美。移动操作并非都比拷贝廉价、并非一直如你期盼的廉价、也并非在每个具有有效移动语义的地方被调用。 <b>type&amp;&amp;</b> 也并非一直代表右值引用。
</p>

<p>
无论你对那些特性进行多么深入的研究，它们看上去似乎总是隐藏着更多的秘密。幸运的是，它们并非深不可测。本章将助你打开这扇神秘的大门，跨过大门，你将对C++11中的这部分内容有更深入的理解。你将掌握 <b>std::move</b> 和 <b>std::forward</b> 的使用语境，并对那歧义性十足的"type&amp;&amp;"有更本质的理解，当然，你也将领悟到为何移动操作(move operation)会表现出令人惊奇的多样性行为。之后，我们又回到了原点，因为移动语义、完美转发和右值引用看起来似乎再次变得非常直白。但现在，它们已不再神秘。
</p>

<p>
在本章的所有条款中，你需要记住，实参永远是左值，即便形参类型为右值引用！这点尤为重要。例如，给定如下函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">w</span>);
</pre>
</div>

<p>
w是一个左值，尽管它的类型为Widget的右值引用。（如果你感到惊讶，请复习本书第二页中左值与右值相关的内容。）
</p>
</div>

<div id="outline-container-orgc2d10a4" class="outline-3">
<h3 id="条款23理解stdmove和stdforward."><a id="orgc2d10a4"></a>条款23：理解std::move和std::forward.</h3>
<div class="outline-text-3" id="text-条款23理解stdmove和stdforward.">
<p>
了解 <b>std::move</b> 和 <b>std::forward</b> 不会做些什么非常有用。 <b>std::move</b> 不会移动任何东西。 <b>std::forward</b> 也不会转发任何东西。它们不会在运行时做任何事情，不会生成哪怕是一比特的可执行代码。
</p>

<p>
<b>std::move</b> 和 <b>std::forward</b> 仅仅是两个转换函数（其实是函数模板）。 <b>std::move</b> 无条件的将它的实参转换为右值，而 <b>std::forward</b> 仅在满足条件的情况下，才执行这一转换（转换为右值）。这一解释虽触发了一连串的疑问，但这却是事实。
</p>

<p>
为了更好的诠释这一事实，我们复刻了C++11中 <b>std::move</b> 的实现，它只是一个例子，虽未完全符合标准（C++标准），但已非常接近：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #a1db00;">typename</span> <span style="color: #5fafd7;">remove_reference</span>&lt;<span style="color: #00d7af;">T</span>&gt;::<span style="color: #00d7af;">type</span>&amp;&amp;           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">in namespace std</span>
<span class="linenr">3 </span><span style="color: #ffd700;">move</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>)
<span class="linenr">4 </span>{
<span class="linenr">5 </span>    <span style="color: #a1db00;">using</span> <span style="color: #00d7af;">ReturnType</span> =                         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">alias declaration;</span>
<span class="linenr">6 </span>        <span style="color: #a1db00;">typename</span> <span style="color: #5fafd7;">remove_reference</span>&lt;<span style="color: #00d7af;">T</span>&gt;::<span style="color: #00d7af;">type</span>&amp;&amp;;  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">see Item 9</span>
<span class="linenr">7 </span>
<span class="linenr">8 </span>    <span style="color: #a1db00;">return</span> <span style="color: #a1db00;">static_cast</span>&lt;<span style="color: #00d7af;">ReturnType</span>&gt;(param);
<span class="linenr">9 </span>}
</pre>
</div>

<p>
我为你高亮标识了代码中的两个部分：函数名及转换语句。标识函数名是因为返回值类型过于复杂，我不希望你迷失其中失去耐心，而那条转换语句，则包含了此函数的精髓。正如你所见， <b>std::move</b> 接收一对象的引用（通用引用: universal reference，详情参阅<a href="./item24.html">条款24</a>），并返回该对象的引用。
</p>

<p>
返回值中的"&amp;&amp;"暗示我们， <b>std::move</b> 返回一右值引用，但正如<a href="./item28.html">条款28</a>所述，如果 <b>T</b> 恰巧是一左值引用， <b>T&amp;&amp;</b> 将同为左值引用。为避免这一情况，型别类型判定技法（type trait，参照<a href="./item9.html">条款9</a>）中的 <b>std::remove_reference</b> 便派上了用场，它作用与 <b>T</b> ，以确保"&amp;&amp;"被应用与一个型别（a type）而不是引用。这对确保 <b>std::move</b> 返回右值引用非常重要，因为函数返回的右值引用是右值。因此 <b>std::move</b> 将传递给它的参数转换为右值，这便是它所做的一切。
</p>

<p>
当然，用C++14实现 <b>std::move</b> 将更加优雅。这归功于函数的返回值类型推导（参照<a href="./item3.html">条款3</a>）及标准库中的模板别名 <b>std::remove_reference_t</b> （参照<a href="./item9.html">条款9</a>），实现如下：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">C++14; still in</span>
<span class="linenr">2 </span><span style="color: #a1db00;">decltype</span>(<span style="color: #a1db00;">auto</span>) <span style="color: #ffd700;">move</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>)      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">namespace std</span>
<span class="linenr">3 </span>{
<span class="linenr">4 </span>    <span style="color: #a1db00;">using</span> <span style="color: #00d7af;">ReturnType</span> = <span style="color: #00d7af;">remove_reference_t</span>&lt;<span style="color: #00d7af;">T</span>&gt;&amp;&amp;;
<span class="linenr">5 </span>    <span style="color: #a1db00;">return</span> <span style="color: #a1db00;">static_cast</span>&lt;<span style="color: #00d7af;">ReturnType</span>&gt;(param);
<span class="linenr">6 </span>}
</pre>
</div>

<p>
看起来更加简单了，是不是？
</p>

<p>
正因如上所诉（ <b>std::move</b> 只是将传递给它的参数转换为右值），许多人建议将它命名为 <b>rvalue_cast</b> 之类的东西。尽管如此，它仍被命名为 <b>std::move</b> ，所以，你必须要记住： <b>std::move</b> 仅转换不移动。
</p>

<p>
当然，右值可以被移动，所以，对一个对象调用 <b>std::move</b> 将告诉编译器，它可以被移动。这便是这一命名的用意：一眼便可看出该对象可以被移动。
</p>

<p>
事实上，只有右值能被移动。假设你正编写一个备注类，它的构造函数接收一个用以描述备注内容的 <b>std::string</b> 对象，并将其拷贝至该类的数据成员中。遵循<a href="./item24.html">条款24</a>的建议，我们将该参数以值传递：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Annotation</span> {
<span class="linenr">2 </span><span style="color: #a1db00;">public</span>:
<span class="linenr">3 </span>    <span style="color: #a1db00;">explicit</span> <span style="color: #ffd700;">Annotation</span>(<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">text</span>); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param to be copied,</span>
<span class="linenr">4 </span>    ...                                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">so per Item 41,</span>
<span class="linenr">5 </span>};                                         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">pass by value</span>
</pre>
</div>

<p>
可是， <b>Annotation</b> 的构造函数只需要读取 <b>text</b> 的内容，不需要对它做任何修改。因此，基于 <b>尽可能的使用const</b> 这一古老传统，你将你的申明稍作改进：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Annotation</span> {
<span class="linenr">2 </span><span style="color: #a1db00;">public</span>:
<span class="linenr">3 </span>    <span style="color: #a1db00;">explicit</span> <span style="color: #ffd700;">Annotation</span>(<span style="color: #a1db00;">const</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">text</span>);
<span class="linenr">4 </span>    ...
<span class="linenr">5 </span>};
</pre>
</div>

<p>
最后，为减少 <b>text</b> 至数据成员的一次拷贝开销，你遵循<a href="./item41.html">条款41</a>的建议，对 <b>text</b> 使用 <b>std::move</b> ，以便产生一个右值：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Annotation</span> {
<span class="linenr"> 2 </span><span style="color: #a1db00;">public</span>:
<span class="linenr"> 3 </span>    <span style="color: #a1db00;">explicit</span> <span style="color: #ffd700;">Annotation</span>(<span style="color: #a1db00;">const</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">text</span>)
<span class="linenr"> 4 </span>    : value(<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">move</span>(<span style="color: #ff8700;">text</span>))  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">"move" text into value; this code</span>
<span class="linenr"> 5 </span>    {...}                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">doesn't do what it seems to!</span>
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span>    ...
<span class="linenr"> 8 </span>
<span class="linenr"> 9 </span><span style="color: #a1db00;">private</span>:
<span class="linenr">10 </span>    <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">value</span>;
<span class="linenr">11 </span>};
</pre>
</div>

<p>
编译、链接、运行，它运行的如你所愿，却与你追求的完美相差甚远，只因 <b>text</b> 未被移动，而是拷贝。 <b>text</b> 虽被 <b>std::move</b> 转换为了右值，但它却被申明为 <b>const std::string</b> ，因此，在被转换前， <b>text</b> 是一 <b>const std::string</b> 类型的左值，在转换后，常属性得以保留，变成一 <b>const std::string</b> 类型的右值。
</p>

<p>
思考一下编译器选择调用 <b>std::string</b> 构造函数的情形，它有两种可能性：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">string</span> {               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std::string is actually a</span>
<span class="linenr">2 </span><span style="color: #a1db00;">public</span>:                      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">typedef of std::basic_string&lt;char&gt;</span>
<span class="linenr">3 </span>    ...
<span class="linenr">4 </span>    string(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">string</span>&amp; <span style="color: #ff8700;">rhs</span>); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">copy ctor</span>
<span class="linenr">5 </span>    <span style="color: #ffd700;">string</span>(<span style="color: #00d7af;">string</span>&amp;&amp; <span style="color: #ff8700;">rhs</span>);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">move ctor</span>
<span class="linenr">6 </span>};
</pre>
</div>

<p>
在 <b>Annotation</b> 类的构造函数初始化列表中， <b>std::move(text)</b> 的结果是一个 <b>const std::string</b> 类型的右值。它不能被传递至 <b>std::string</b> 的移动构造函数，因为它（移动构造函数）接收一非常量 <b>std::string</b> 的右值引用作为参数。但它却可以被传递给拷贝构造函数，因为常左值引用可以绑定至常右值。因此， <b>value</b> 的初始化便调用了 <b>std::string</b> 的拷贝构造函数，尽管 <b>text</b> 已经被转换为右值！这一行为对维持常量正确性（常量属性的正确性：const-correctness）非常重要，毕竟将对象的值移出该对象便意味着修改了该对象<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>，因此，语法层面上应禁止将const对象传递至那些会对对象进行修改的函数（正如拷贝构造函数）。
</p>

<p>
从这个例子中，我们得出两条结论。第一，不要将有可能进行移动操作的对象申明为 <b>const</b> ，因为对常量对象的移动操作，会自动的转换为拷贝操作。第二， <b>std::move</b> 并不会移动任何东西，也不能保证其转换出的对象能被移动。唯一能确定的是 <b>std::move</b> 处理后的对象是一个右值。
</p>

<p>
<b>std::forward</b> 与 <b>std::move</b> 类似，只不过 <b>std::move</b> 会无条件的将其参数转换为右值，而 <b>std::forward</b> 只会在特定的情形下才进行转换。因此， <b>std::forward</b> 是有条件的转换。要理解它的转换条件，就需要我们回忆一下 <b>std::forward</b> 的使用情景。最常用的使用情景便是在一接收通用引用为参数的模板函数中，将其参数传递给另一函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">process</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">Widget</span>&amp; <span style="color: #ff8700;">lvalArg</span>);     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">process lvalues</span>
<span class="linenr"> 2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">process</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">rvalArg</span>);          <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">process rvalues</span>
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">template that passes</span>
<span class="linenr"> 5 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">logAndProcess</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>)            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param to process</span>
<span class="linenr"> 6 </span>{
<span class="linenr"> 7 </span>    <span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">now</span> =                           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">get current time</span>
<span class="linenr"> 8 </span>       <span style="color: #5fafd7;">std</span>::<span style="color: #5fafd7;">chrono</span>::<span style="color: #5fafd7;">system_clock</span>::now();
<span class="linenr"> 9 </span>
<span class="linenr">10 </span>    makeLogEntry(<span style="color: #ff4ea3;">"Calling 'process'"</span>, now);
<span class="linenr">11 </span>    process(<span style="color: #5fafd7;">std</span>::forward&lt;<span style="color: #00d7af;">T</span>&gt;(param));
<span class="linenr">12 </span>}
</pre>
</div>

<p>
考虑分别用左值和右值调用 <b>logAndProcess</b> 方法的情形：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">Widget</span> <span style="color: #ff8700;">w</span>;
<span class="linenr">2 </span>
<span class="linenr">3 </span>logAndProcess(w);             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">call with lvalue</span>
<span class="linenr">4 </span>logAndProcess(<span style="color: #5fafd7;">std</span>::move(w));  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">call with rvalue</span>
</pre>
</div>

<p>
在函数 <b>logAndProcess</b> 中，参数 <b>param</b> 被传递给 <b>process</b> 函数， <b>process</b> 函数有针对左值及右值参数的重载。我们自然希望，在使用左值调用 <b>process</b> 函数时，该左值会被转发给 <b>process</b> ，而在使用右值调用 <b>logAndProcess</b> 函数时，则会调用相应的右值重载版本。
</p>

<p>
可是，所有的参数（正如所有的函数参数一样），都是左值。因此，在函数 <b>logAndProcess</b> 中对 <b>process</b> 的调用，都会触发左值重载版本的 <b>process</b> 函数。为阻止这种情况发生，我们需要一种机制，它能在适当的时候 ──当传递给 <b>logAndProcsss</b> 的参数是右值的时候── 将参数转换为右值。这便是 <b>std::forward</b> 所做的事情。因此， <b>std::forward</b> 被称为条件转换：它仅在其参数由右值初始化时，才将其转换为右值。
</p>

<p>
你也许会想知道， <b>std::forward</b> 是如何知道其参数是由右值初始化而来的。例如，在如上例子中， <b>std::forward</b> 是如何知道初始化其参数的是左值还是右值？要点在于 <b>logAndProcess</b> 的模板参数T，参数的左、右值信息便隐藏其中，借由 <b>std::forward</b> 将其还原。详细情况我将与<a href="./item28.html">条款28</a>中为你讲述。
</p>

<p>
<b>std::move</b> 和 <b>std::forward</b> 都被归结为类型转换函数，它们的唯一区别是 <b>std::move</b> 总是进行转换，而 <b>std::forward</b> 则只会在需要的时候进行转换，你也许会问，我们是否可以摒弃 <b>std::move</b> ，只使用 <b>std::forward</b> ？从技术层面来说，你可以那么做， <b>std::move</b> 不是必须的。当然，你可以认为它们两都不是必须的，因为你可以在任何需要转换的地方手动编写转换代码，但我还是希望大家尽量使用它们，毕竟随处可见的相似代码（手动编写的类型转换代码），并不符合软件开发的哲学。
</p>

<p>
<b>std::move</b> 的吸引力在于方便、减少可能的错误以及语义清晰。如果我们需要统计某移动构造函数的调用次数，我们只需要定义一静态计数器，将其于移动构造函数中自增，假使该类仅有一个 <b>std::string</b> 类型的非静态成员变量，那么，移动构造函数的实现便非常简单（使用 <b>std::move</b> ）：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Widget</span> {
<span class="linenr"> 2 </span><span style="color: #a1db00;">public</span>:
<span class="linenr"> 3 </span>    <span style="color: #ffd700;">Widget</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">rhs</span>)
<span class="linenr"> 4 </span>        : s(<span style="color: #5fafd7;">std</span>::move(rhs.s))
<span class="linenr"> 5 </span>    { ++moveCtorCalls; }
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span>    ...
<span class="linenr"> 8 </span><span style="color: #a1db00;">private</span>:
<span class="linenr"> 9 </span>    <span style="color: #a1db00;">static</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">size_t</span> <span style="color: #ff8700;">moveCtorCalls</span>;
<span class="linenr">10 </span>    <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">string</span> <span style="color: #ff8700;">s</span>;
<span class="linenr">11 </span>};
</pre>
</div>

<p>
当然，也可以使用 <b>std::forward</b> 实现该函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">class</span> <span style="color: #00d7af;">Widget</span> {
<span class="linenr">2 </span><span style="color: #a1db00;">public</span>:
<span class="linenr">3 </span>    <span style="color: #ffd700;">Widget</span>(<span style="color: #00d7af;">Widget</span>&amp;&amp; <span style="color: #ff8700;">rhs</span>)                         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">unconventional,</span>
<span class="linenr">4 </span>        : s(<span style="color: #5fafd7;">std</span>::forward&lt;<span style="color: #5fafd7;">std</span>::string&gt;(rhs.s))    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">undesirable</span>
<span class="linenr">5 </span>    { ++moveCtorCalls; }                         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">implementation</span>
<span class="linenr">6 </span>
<span class="linenr">7 </span>    ...
<span class="linenr">8 </span>};
</pre>
</div>

<p>
注意，在使用 <b>std::move</b> 时，你只需向它传递一个参数（rhs.s）即可，而 <b>std::forward</b> 还需要指定一个模板参数（ <b>std::string</b> ），你不需要为它（模板参数）指定引用类型，因为这（它是一个右值）已经是约定俗成的东西了（参阅<a href="./item28.html">条款28</a>）。因此使用 <b>std::move</b> 比 <b>std::forward</b> 更方便，还能避免错误的类型参数导致的行为异常（例如：传入 <b>std::string&amp;</b> 将导致成员变量 <b>s</b> 被拷贝构造，而不是移动构造）。
</p>

<p>
更重要的是， <b>std::move</b> 的使用给我们传递了无条件右值转换的语义，而 <b>std::forward</b> 则表明仅会对绑定至右值的参数进行转换，这是两种完全不同的行为，前者是典型的移动，后者只是将对象── <b>转发</b> ──给另一函数，并保留它的左、右值属性，因此，设计两个完全不同的函数（及函数名）区分它们，是一个很好的决议。
</p>
</div>

<div id="outline-container-orgd4f03aa" class="outline-4">
<h4 id="记住"><a id="orgd4f03aa"></a>记住：</h4>
<div class="outline-text-4" id="text-记住">
<ul class="org-ul">
<li><b>std::move</b> 无条件的将其参数转换为右值，它不会进行任何移动。</li>
<li><b>std::forward</b> 只会在其参数为右值时，才会进行转换。</li>
<li><b>std::move</b> 与 <b>std::forward</b> 均无运行时开销。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Moving a value out of an object generally modifies the object.意为对该对象调用 <b>std::move</b> 后，该对象变成了右值，其实便是修改了该对象，与该对象的const属性相矛盾。
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-30 Wed 16:17</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;

&lt;div id=&quot;outline-container-orgdc926b6&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;第五章-右值引用移动语义及完美转发&quot;&gt;&lt;a id=&quot;orgdc926b6&quot;&gt;&lt;/a&gt;第五章 右值引用、移动语义及完美转发&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-第五章-右值引用移动语义及完美转发&quot;&gt;
&lt;p&gt;
当你初次学习它们时，移动语义和完美转发看起来非常直白：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;b&gt;移动语义&lt;/b&gt; 让编译器将代价高昂的拷贝操作替换为相对低廉的移动操作。正如其名，拷贝构造函数及拷贝赋值函数给予你控制对象复制的能力，与此类似，移动构造函数和移动赋值函数则给予你控制移动语义的能力。移动语义还允许你创建move-only类型的对象，例如： &lt;b&gt;std::unique_ptr&lt;/b&gt; 、 &lt;b&gt;std::future&lt;/b&gt; 和 &lt;b&gt;std::thread&lt;/b&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;b&gt;完美转发&lt;/b&gt; 使我们可以将模板函数的实参（任意修饰符的实参）转发给另一函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
右值引用是这两个迥异特性的粘合剂。它们是构成移动语义及完美转发的基石。
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="Effective Modern C++" scheme="http://paruka.me/categories/Translation/Effective-Modern-C/"/>
    
    
      <category term="Effective Modern C++" scheme="http://paruka.me/tags/Effective-Modern-C/"/>
    
      <category term="Press Ban" scheme="http://paruka.me/tags/Press-Ban/"/>
    
      <category term="禁止转载" scheme="http://paruka.me/tags/%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Value categories</title>
    <link href="http://paruka.me/translation/cppreference/value-categories.html"/>
    <id>http://paruka.me/translation/cppreference/value-categories.html</id>
    <published>2016-12-29T17:42:00.000Z</published>
    <updated>2017-08-06T18:40:49.011Z</updated>
    
    <content type="html"><![CDATA[<div id="content">
<p>
翻译至<a href="http://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="external">cppreference</a>、<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/language/value_category&amp;oldid=85137" target="_blank" rel="external">cppreference</a>，并对其进行了整合。(虽然我并不明白这两个网站的区别&#x2026;)
</p>

<p>
每一个C++<a href="http://en.cppreference.com/w/cpp/language/expressions" target="_blank" rel="external">表达式</a>（有操作数的运算符、字面值、变量名等）都被赋予两种独立的属性：型别和值类型（value categories）。每一个表达式都有一些非引用的类型，且归属与以下三种值类型中的一种：prvalue、xvalue、lvalue。它们的定义如下：
</p>
<a id="more"></a>

<ul class="org-ul">
<li>glvalue<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>是一个其值（运算结果）能标识一个对象、位域或函数的表达式。</li>
<li>prvalue<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>表达式既
<ul class="org-ul">
<li><b>是一个运算符（使用某些操作数运算后）的值（这样的prvalue没有返回对象），也能</b></li>
<li><b>（用其值）初始化一个对象或位域（这样的prvalue我们称其拥有返回对象）。所有类、数组类型的prvalue都有一个返回值，哪怕它会被抛弃。</b></li>
</ul></li>
<li>xvalue<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>是一个（其对象或位域）可被复用的glvalue。</li>
<li>lvalue是那些不属于xvalue的glvalue。</li>
<li>rvalue是一个prvalue或xvalue。</li>
</ul>

<p>
注意: 这一分类方式与之前的C++标准相比有巨大的变化，详情请看<a href="http://en.cppreference.com/w/cpp/language/value_category#History" target="_blank" rel="external">历史</a>。
</p>

<div id="outline-container-org3d31af4" class="outline-2">
<h2 id="primary-categories"><a id="org3d31af4"></a>Primary categories</h2>
<div class="outline-text-2" id="text-primary-categories">
<p>
主类型对应表达式的两个属性：
</p>
<ul class="org-ul">
<li><i>有身份</i> : 可以确定各表达式标识的对象是否为同一对象，例如：比较它们的地址或者调用它们的标识函数。</li>
<li><i>可被移动</i> : 移动构造函数、移动赋值函数或其它实现了移动语意的函数是否可绑定至该表达式。</li>
</ul>

<p>
因此：
</p>
<ul class="org-ul">
<li>有身份且不能被移动的表达式为 <i>lvalue</i> 表达式；</li>
<li>有身份且能被移动的表达式为 <i>xvalue</i> 表达式；</li>
<li>无身份且能被移动的表达式为 <i>prvalue</i> 表达式；</li>
<li>无身份且不能被移动的表达式并不存在。</li>
</ul>
</div>

<div id="outline-container-orgc02a7ec" class="outline-3">
<h3 id="lvalue"><a id="orgc02a7ec"></a><b>lvalue</b></h3>
<div class="outline-text-3" id="text-lvalue">
<p>
<i>lvalue</i> ("left value")表达式有身份且不能被移动。"左值"这个名字具有历史性的意义，它完美的标识了它在CPL编程语言中的作用：赋值运算符的左操作数。
</p>

<p>
以下表达式均为lvalue（左值）表达式:
</p>
<ul class="org-ul">
<li>作用域内的、任意类型的变量名或函数名，例如： <code>std::cin</code> 、 <code>std::endl</code> 。即便变量的类型是右值引用，由它的名字组成的表达式也是一个左值表达式。</li>
<li>一个返回值为左值引用的函数调用或返回值为左值引用的运算符重载表达式，例如： <code>std::getline(std::cin, str)</code> 、 <code>std::cout &lt;&lt; 1</code> 、 <code>str1 = str2</code> 、 <code>++it</code> 。</li>
<li><code>a=b</code> 、 <code>a+=b</code> 、 <code>a%=b</code> ，及其它内置的<a href="http://en.cppreference.com/w/cpp/language/operator_assignment" target="_blank" rel="external">赋值、复合赋值</a>表达式。</li>
<li><code>++a</code> 和 <code>--a</code> ：　内置的<a href="http://en.cppreference.com/w/cpp/language/operator_incdec#Built-in_prefix_operators" target="_blank" rel="external">前置自增、前置自减</a>表达式。</li>
<li><code>*p</code> ：内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_indirection_operator" target="_blank" rel="external">指针取值</a>表达式。</li>
<li><code>a[n]</code> 和 <code>p[n]</code> ：内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_subscript_operator" target="_blank" rel="external">取下标</a>表达式， <code>a不能为右值数组。(since c++11)</code> 。</li>
<li><code>a.m</code> ：<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators" target="_blank" rel="external">对象成员</a>表达式，除非m是枚举或非静态成员函数，又或者a是右值且m为非引用类型的非静态成员。</li>
<li><code>p-&gt;m</code> ：内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators" target="_blank" rel="external">指针所指对象的成员</a>表达式，m不能为枚举或非静态成员函数。</li>
<li><code>a.*mp</code>: <a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_pointer-to-member_access_operators" target="_blank" rel="external">对象成员指针</a>表达式，a必须为左值且mp必须指向数据成员。</li>
<li><code>p-&gt;*mp</code> ：内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_pointer-to-member_access_operators" target="_blank" rel="external">指向成员指针的指针</a>表达式，mp必须指向数据成员。</li>
<li><code>a, b</code>: 内置的<a href="http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator" target="_blank" rel="external">逗号</a>表达式，b必须为左值。</li>
<li><code>a ? b : c</code> ：某些<a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator" target="_blank" rel="external">三元条件</a>表达式。</li>
<li><a href="http://en.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="external">字符串字面值</a>，例如： <code>"Hello World!"</code> 。</li>
<li>转换为左值引用的转换表达式，例如: <code>static_cast&lt;int&amp;&gt;(x)</code> 。</li>
<li>对返回值为右值引用的方法的调用或返回值为右值引用的运算符重载表达式(since c++11)。</li>
<li>转换为函数右值引用的转换表达式，例如： <code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code> (since c++11)。</li>
</ul>
</div>

<div id="outline-container-orgcecc9f3" class="outline-4">
<h4 id="orgcecc9f3">属性:</h4>
<div class="outline-text-4" id="text-orgcecc9f3">
<ul class="org-ul">
<li>拥有glvalue的所有属性(稍后介绍)。</li>
<li>可以获取左值的地址： <code>&amp;++i</code> <sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>和 <code>&amp;std::endl</code> 都是合法的表达式。</li>
<li>可修改的左值可以做为内置赋值、复合赋值运算符的左操作数。</li>
<li>左值可以用来<a href="http://en.cppreference.com/w/cpp/language/reference_initialization" target="_blank" rel="external">初始化左值引用</a>；此时该表达式标识的对象将被赋予一个全新的别名。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd8ba291" class="outline-3">
<h3 id="prvalue"><a id="orgd8ba291"></a><b>prvalue</b></h3>
<div class="outline-text-3" id="text-prvalue">
<p>
<i>prvalue("pure rvalue")</i> 表达式是那些 <i>没有身份</i> 且 <i>可以被移动</i> 的表达式。
</p>

<p>
以下表达式均为prvalue表达式：
</p>
<ul class="org-ul">
<li><a href="http://en.cppreference.com/w/cpp/language/expressions#Literals" target="_blank" rel="external">字面值</a>（除<a href="http://en.cppreference.com/w/cpp/language/string_literal" target="_blank" rel="external">字符串字面值</a>），例如： <code>42</code> 、 <code>true</code> 或 <code>nullptr</code> ；</li>
<li>返回值为非引用类型的函数的调用或返回值为非引用的运算符重载表达式，例如： <code>str.substr(1, 2)</code> 、 <code>str1+str2</code> 、 <code>it++</code> 。</li>
<li><code>a++</code> 及 <code>a--</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_incdec#Built-in_postfix_operators" target="_blank" rel="external">后置自增、自减运算符</a>表达式；</li>
<li><code>a+b</code> 、 <code>a%b</code> 、 <code>a&amp;b</code> 、 <code>a&lt;&lt;b</code> 及其它所有的内置<a href="http://en.cppreference.com/w/cpp/language/operator_arithmetic" target="_blank" rel="external">算数</a>表达式；</li>
<li><code>a&amp;&amp;b</code> 、 <code>a||b</code> 、 <code>~a</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_logical" target="_blank" rel="external">逻辑</a>表达式；</li>
<li><code>a&lt;b</code> 、a==b、a&gt;=b 及其它所有内置的<a href="http://en.cppreference.com/w/cpp/language/operator_comparison" target="_blank" rel="external">比较</a>表达式；</li>
<li><code>&amp;a</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_address-of_operator" target="_blank" rel="external">取地址</a>表达式；</li>
<li><code>a.m</code> ，<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators" target="_blank" rel="external">对象成员</a>表达式，其中m必须为枚举或非静态成员函数<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>，或 <code>a为rvalue且m为非引用类型的非静态数据成员（until c++11）</code> ；</li>
<li><code>p-&gt;m</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators" target="_blank" rel="external">指针所指对象的成员</a>表达式，其中m必须为枚举或非静态成员函数<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>；</li>
<li><code>a.*mp</code> ，<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_pointer-to-member_access_operators" target="_blank" rel="external">对象的成员指针</a>表达式，其中mp是一个指向成员函数的指针<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>，或 <code>a是一个右值且mp为一指向数据成员的指针（until C++11）</code> ；</li>
<li><code>p-&gt;*mp</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_pointer-to-member_access_operators" target="_blank" rel="external">指向成员指针的指针</a>表达式，其中mp为指向成员函数的指针<sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup>；</li>
<li><code>a, b</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator" target="_blank" rel="external">逗号</a>表达式，其中b为右值；</li>
<li><code>a ? b : c</code> ，某些<a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator" target="_blank" rel="external">三元条件</a>表达式；</li>
<li>至非引用类型的转换表达式，例如： <code>static_cast&lt;double&gt;(x)</code> 、 <code>std::string{}</code> 或 <code>(int)42</code> ；</li>
<li><a href="http://en.cppreference.com/w/cpp/language/this" target="_blank" rel="external">this</a>指针；</li>
<li><a href="http://en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="external">lambda表达式</a>，例如： <code>[](int x){ return x * x; }。(since c++11)</code> 。</li>
</ul>
</div>
<div id="outline-container-orgf2c9fd1" class="outline-4">
<h4 id="orgf2c9fd1">属性</h4>
<div class="outline-text-4" id="text-orgf2c9fd1">
<ul class="org-ul">
<li>拥有rvalue的所有属性（稍后介绍）。</li>
<li>prvalue不具备<a href="http://en.cppreference.com/w/cpp/language/object#Polymorphic_objects" target="_blank" rel="external">多态性</a>：它所标示的对象的<a href="http://en.cppreference.com/w/cpp/language/type#Dynamic_type" target="_blank" rel="external">动态型别</a>总是表达式本身的型别。</li>
<li>非自定义类非数组（non-class non-array）的prvalue不能被<a href="http://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="external">cv-qualified</a>（不能具备const或volatile属性）。</li>
<li>prvalue不能为<a href="http://en.cppreference.com/w/cpp/language/type#Incomplete_type" target="_blank" rel="external">不完整的类型</a>（除非它是void类型或出现在<a href="http://en.cppreference.com/w/cpp/language/decltype" target="_blank" rel="external">decltype</a>表达式中）。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcc72855" class="outline-3">
<h3 id="xvalue"><a id="orgcc72855"></a><b>xvalue</b></h3>
<div class="outline-text-3" id="text-xvalue">
<p>
<i>xvalue</i> ("expiring value")表达式是那些 <i>有身份</i> 且 <i>可以被移动</i> 的表达式。
</p>

<p>
以下表达式均为xvalue表达式：
</p>
<ul class="org-ul">
<li>返回值为右值引用的函数（的调用）或返回值为右值引用的运算符重载表达式，例如： <code>std::move(x)</code> ；</li>
<li><code>a[n]</code> ，内置的<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_subscript_operator" target="_blank" rel="external">取下标</a>表达式，其中a为一个 <code>右值数组(until C++17)</code> 或 <code>xvalue数组(since C++17)</code> ；</li>
<li><code>a.m</code> ，<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators" target="_blank" rel="external">对象成员</a>表达式，其中a是一个右值且m为非引用类型的非静态数据成员；</li>
<li><code>a.*mp</code> ，<a href="http://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_pointer-to-member_access_operators" target="_blank" rel="external">对象的成员指针</a>表达式，其中a为右值（rvalue）且mp为指向数据成员的指针；</li>
<li><code>a ? b : c</code> ，某些<a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator" target="_blank" rel="external">三元条件</a>表达式；</li>
<li>至右值引用的转换表达式，例如： <code>static_cast&lt;char&amp;&amp;&gt;(x)</code> 。</li>
</ul>
</div>
<div id="outline-container-org57ef3fa" class="outline-4">
<h4 id="属性"><a id="org57ef3fa"></a>属性</h4>
<div class="outline-text-4" id="text-属性">
<ul class="org-ul">
<li>拥有rvalue的所有属性（稍后介绍）。</li>
<li>拥有glvalue的所有属性（稍后介绍）。</li>
</ul>

<p>
注意：xvalue与rvalue类似，它绑定至右值引用，但xvalue也拥有glvalue的属性，它能被<a href="http://en.cppreference.com/w/cpp/language/object#Polymorphic_objects" target="_blank" rel="external">多态化(polymorphic)</a>，且非对象类型的xvalue也能被<a href="http://en.cppreference.com/w/cpp/language/cv" target="_blank" rel="external">cv-qualified</a>。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org09ec044" class="outline-2">
<h2 id="mixed-categories"><a id="org09ec044"></a>Mixed categories</h2>
<div class="outline-text-2" id="text-mixed-categories">
</div>

<div id="outline-container-org6cb09cd" class="outline-3">
<h3 id="glvalue"><a id="org6cb09cd"></a><b>glvalue</b></h3>
<div class="outline-text-3" id="text-glvalue">
<p>
<i>glvalue</i> 表达式是 <i>lvalue</i> 表达式与 <i>xvalue</i> 表达式的总称（它是一个 <i>lvalue</i> 表达式或 <i>xvalue</i> 表达式）。它 <i>有身份</i> ，但在 <i>可移动性</i> 上没有硬性规定。
</p>
</div>
<div id="outline-container-org4ccfadb" class="outline-4">
<h4 id="org4ccfadb">属性</h4>
<div class="outline-text-4" id="text-org4ccfadb">
<ul class="org-ul">
<li>glvalue可以被隐式转换为prvalue，这归功于左值至右值（lvalue-to-rvalue）、数组至指针、函数至指针的<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="external">隐形转化规则</a>。</li>
<li>glvalue可以被<a href="http://en.cppreference.com/w/cpp/language/object#Polymorphic_objects" target="_blank" rel="external">多态化(polymorphic)</a>： 表达式标识对象的<a href="http://en.cppreference.com/w/cpp/language/type#Dynamic_type" target="_blank" rel="external">动态类型标识符</a>并不总是该对象的静态类型。</li>
<li>在表达式合法的前提下，glvalue可以为<a href="http://en.cppreference.com/w/cpp/language/type#Incomplete_type" target="_blank" rel="external">不完整的类型</a>。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc10a1c5" class="outline-3">
<h3 id="rvalue"><a id="orgc10a1c5"></a><b>rvalue</b></h3>
<div class="outline-text-3" id="text-rvalue">
<p>
<i>rvalue</i> 表达式是 <i>prvalue</i> 表达式和 <i>xvalue</i> 表达式的总称。它 <i>能被移动</i> ，但对 <i>身份</i> 没有硬性规定。"右值"这个名字具有历史性的意义，它完美的标识了它在CPL编程语言中的作用：赋值运算符的右操作数。
</p>
</div>
<div id="outline-container-org92dc031" class="outline-4">
<h4 id="org92dc031">属性</h4>
<div class="outline-text-4" id="text-org92dc031">
<ul class="org-ul">
<li>不能获取右值的地址： <code>&amp;int()</code> 、 <code>&amp;i++</code> 、 <code>&amp;42</code> 和 <code>&amp;std::move(x)</code> 都是不合法的表达式。</li>
<li>不能被用作内置赋值运算符和内置复合赋值运算符的左操作数。</li>
<li>可以被用来<a href="http://en.cppreference.com/w/cpp/language/reference_initialization" target="_blank" rel="external">初始化常左值引用</a>，此时该右值所标识的对象的生命期将被延续至该常左值引用结束。</li>
<li>可以被用来<a href="http://en.cppreference.com/w/cpp/language/reference_initialization" target="_blank" rel="external">初始化右值引用</a>，此时该右值所标识对象的生命期将被延续至该右值引用结束。(since c++11)</li>
<li>用作函数实参时(arguments)，若函数拥有<a href="http://en.cppreference.com/w/cpp/language/overload_resolution" target="_blank" rel="external">两个重载</a>版本（一个使用右值引用形参，一个使用常左值引用形参），该右值将绑定至右值引用版本的重载函数（因此，如果同时拥有拷贝构造函数及<a href="http://en.cppreference.com/w/cpp/language/move_constructor" target="_blank" rel="external">移动构造函数</a>，右值实参将会调用移动构造函数，拷贝赋值函数及移动赋值函数亦是如此）(since c++11)。</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgda8a6e8" class="outline-2">
<h2 id="special-categories"><a id="orgda8a6e8"></a>Special categories</h2>
<div class="outline-text-2" id="text-special-categories">
</div>

<div id="outline-container-org68af95c" class="outline-3">
<h3 id="pending-member-function-call"><a id="org68af95c"></a><b>Pending member function call</b></h3>
<div class="outline-text-3" id="text-pending-member-function-call">
<p>
以下两组表达式： <code>a.mf</code> 、 <code>p-&gt;mf</code> (mf为<a href="http://en.cppreference.com/w/cpp/language/member_functions" target="_blank" rel="external">非静态成员函数</a>) 及 <code>a.*mfp</code> 、 <code>p-&gt;*mfp</code> (mfp为<a href="http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_member_functions" target="_blank" rel="external">指向成员函数的指针</a>)均被标识为prvalue表达式，但它们不能被用来初始化引用，也不能被用作函数实参或其它任何意图，它们只能被用作函数调用操作符的左操作数： <code>(p-&gt;*mfp)(args)</code> 。
</p>
</div>
</div>
<div id="outline-container-org7dda62c" class="outline-3">
<h3 id="void-expressions"><a id="org7dda62c"></a><b>Void expressions</b></h3>
<div class="outline-text-3" id="text-void-expressions">
<p>
返回值为 <code>void</code> 的函数调用表达式、至 <code>void</code> 的转换表达式及<a href="http://en.cppreference.com/w/cpp/language/throw" target="_blank" rel="external">抛出异常表达式</a>均被标识为prvalue表达式，但它们不能初始化引用及函数实参。它们可以表示某些空值(discarded-value)内容（例如：仅有该表达式的一行代码、逗号表达式的左操作数等），也可以用作 <code>返回值为void的函数</code> 的返回值。此外，抛出异常表达式也可作为<a href="http://en.cppreference.com/w/cpp/language/operator_other" target="_blank" rel="external">问号条件操作符（ <b>?</b> ）</a>的第二个或第三个操作数。
</p>
</div>
</div>

<div id="outline-container-org878c141" class="outline-3">
<h3 id="bit-fields"><a id="org878c141"></a><b>Bit fields</b></h3>
<div class="outline-text-3" id="text-bit-fields">
<p>
<a href="http://en.cppreference.com/w/cpp/language/bit_field" target="_blank" rel="external">位域</a>操作表达式（例如： <code>a.m</code> ，当a为 <code>struct A { int m: 3;}</code> 的左值时）为lvalue表达式：它可以用作赋值操作符的左操作数，但它不能被取地址，也不能被绑定至非常左值引用。常左值引用虽然可以被位域左值初始化，但它只是绑定了该位域的临时拷贝对象，你无法将位域直接绑定至引用。
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
general lvalue
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
pure rvalue
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
expiring value
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
i是内置类型或重载的前置自增运算符返回左值引用
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
special rvalue category, see pending member function call
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
special rvalue category, see pending member function call
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
special rvalue category, see pending member function call
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
special rvalue category, see pending member function call
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-07 Mon 14:22</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;
&lt;p&gt;
翻译至&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/value_category&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cppreference&lt;/a&gt;、&lt;a href=&quot;http://en.cppreference.com/mwiki/index.php?title=cpp/language/value_category&amp;amp;oldid=85137&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cppreference&lt;/a&gt;，并对其进行了整合。(虽然我并不明白这两个网站的区别&amp;#x2026;)
&lt;/p&gt;

&lt;p&gt;
每一个C++&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/expressions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;表达式&lt;/a&gt;（有操作数的运算符、字面值、变量名等）都被赋予两种独立的属性：型别和值类型（value categories）。每一个表达式都有一些非引用的类型，且归属与以下三种值类型中的一种：prvalue、xvalue、lvalue。它们的定义如下：
&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="cppreference" scheme="http://paruka.me/categories/Translation/cppreference/"/>
    
    
      <category term="cppreference" scheme="http://paruka.me/tags/cppreference/"/>
    
  </entry>
  
  <entry>
    <title>条款2：理解auto类型推导</title>
    <link href="http://paruka.me/translation/effective_modern_cpp/item2.html"/>
    <id>http://paruka.me/translation/effective_modern_cpp/item2.html</id>
    <published>2016-10-17T14:02:00.000Z</published>
    <updated>2017-08-06T18:42:09.625Z</updated>
    
    <content type="html"><![CDATA[<div id="content">
<p>
如果你已经阅读了<a href="./item1.html">条款1</a>中关于模板类型推导相关的内容，你应该已经掌握了几乎所有的关于auto类型推导相关的知识，因为与模板类型推导规则相比，auto类型推导规则只有一个例外。这是为什么呢？因为模板类型推导涉及了模板、函数和参数，但auto并不关心那些东西。
</p>

<p>
是的，但这无所谓。在模板类型推导与auto类型推导之间，有一个直接的映射，可以通过一种方法将他们互相转化。
</p>
<a id="more"></a>

<p>
在<a href="./item1.html">条款1</a>中，我们使用如下模板函数对模板类型推导进行讲解：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">ParamType</span> <span style="color: #ff8700;">param</span>);
</pre>
</div>

<p>
并使用如下方式调用：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span>f(expr);                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">call f with some expression</span>
</pre>
</div>

<p>
对于函数f的调用，编译器使用expr来推导T和ParamType的类型。
</p>

<p>
当一个变量被声明为auto，auto便相当与模板中的T，而变量类型描述符<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>相当与ParamType。当然，示例代码总比口头描述更为清晰，因此，举例如下：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x</span> = 27;
</pre>
</div>

<p>
x的类型描述符就是auto本身。而对于如下声明：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">const</span> <span style="color: #a1db00;">auto</span> cx = x;
</pre>
</div>

<p>
x的类型描述符是const auto。若将声明稍作修改：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">const</span> <span style="color: #a1db00;">auto</span>&amp; <span style="color: #ff8700;">rx</span> = x;
</pre>
</div>

<p>
x的类型描述符便变成了const auto&amp;。因此，对于如上例子中x，cx和rx的类型推导，编译器表现的就像是在用相应的初始化表达式对某一函数模板进行调用一样：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #00d7af;">teamplate</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 2 </span><span style="color: #00d7af;">void</span> func_for_x(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">conceptual template for</span>
<span class="linenr"> 3 </span>                            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deducing x's type</span>
<span class="linenr"> 4 </span>
<span class="linenr"> 5 </span>func_for_x(27);             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">conceptual call: param's</span>
<span class="linenr"> 6 </span>                            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deduced type is x's type</span>
<span class="linenr"> 7 </span>
<span class="linenr"> 8 </span>
<span class="linenr"> 9 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">10 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">func_for_cx</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">conceptual template for</span>
<span class="linenr">11 </span>                                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deducing cx's type</span>
<span class="linenr">12 </span>
<span class="linenr">13 </span>func_for_cx(x);                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">conceptual call: param's</span>
<span class="linenr">14 </span>                                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deduced type is cx's type</span>
<span class="linenr">15 </span>
<span class="linenr">16 </span>
<span class="linenr">17 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">18 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">func_for_rx</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">T</span>&amp; <span style="color: #ff8700;">param</span>);  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">conceptual template for</span>
<span class="linenr">19 </span>                                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deducing rx's type</span>
<span class="linenr">20 </span>
<span class="linenr">21 </span>func_for_rx(x);                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">conceptual call: param's</span>
<span class="linenr">22 </span>                                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deduced type is rx's type</span>
</pre>
</div>

<p>
这正如我之前所诉，auto类型推导与模板类型推导只有在某一特殊情况下才显不同（我们即将讨论）。
</p>

<p>
<a href="./item1.html">条款1</a>将模板类型推导规则依ParamType（模板函数形参的类型描述符）分为三种情况。而在auto变量声明中，类型描述符相当与ParamType，因此也有三种情况：
</p>

<ul class="org-ul">
<li>情形1： 类型描述符是一个指针或引用，但不是通用引用<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>。</li>
<li>情形2： 类型描述符是一个通用引用。</li>
<li>情形3： 类型描述符不是引用也不是指针。</li>
</ul>

<p>
我们之前已经看过情形1和情形3的例子了：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x</span> = 27;            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">case 3 (x is neither ptr nor reference)</span>
<span class="linenr">2 </span>
<span class="linenr">3 </span><span style="color: #a1db00;">const</span> <span style="color: #a1db00;">auto</span> x = x;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">case 3 (cx is't either)</span>
<span class="linenr">4 </span>
<span class="linenr">5 </span><span style="color: #a1db00;">const</span> <span style="color: #a1db00;">auto</span>&amp; <span style="color: #ff8700;">rx</span> = x;     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">cast 1 (rx is a non-universal ref.)</span>
</pre>
</div>

<p>
当然，情形2也如你所料：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">uref1</span> = x;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">x is int and and lvalue,</span>
<span class="linenr">2 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">so uref1's type is int&amp;.</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span><span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">uref2</span> = cx;      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">cx is const int and lvalue,</span>
<span class="linenr">5 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">so uref2's type is const int&amp;.</span>
<span class="linenr">6 </span>
<span class="linenr">7 </span><span style="color: #a1db00;">auto</span>&amp;&amp; <span style="color: #ff8700;">uref3</span> = 27;      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">27 is in and rvalue,</span>
<span class="linenr">8 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">so uref3's type is int&amp;&amp;</span>
</pre>
</div>

<p>
<a href="./item1.html">条款1</a>中讲到，数组和函数在传递给非引用类型形参时会退化为相应的指针，当然，此规则对auto类型推导同样适用：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span> <span style="color: #ff8700;">name</span>[] = <span style="color: #ff4ea3;">"R. N. Briggs"</span>;  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">name's type is const char[13]</span>
<span class="linenr"> 2 </span>
<span class="linenr"> 3 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">arr1</span> = name;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">arr1's type is const* char</span>
<span class="linenr"> 4 </span>
<span class="linenr"> 5 </span><span style="color: #a1db00;">auto</span>&amp; <span style="color: #ff8700;">arr2</span> = name;      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">arr2's type is const char (&amp;)[13]</span>
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span>
<span class="linenr"> 8 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">someFunc</span>(<span style="color: #00d7af;">int</span>, <span style="color: #00d7af;">double</span>);   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">someFunc is a function;</span>
<span class="linenr"> 9 </span>                              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is void (int, double)</span>
<span class="linenr">10 </span>
<span class="linenr">11 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">func1</span> = someFunc;        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">func1's type is void (*)(int, double)</span>
<span class="linenr">12 </span>
<span class="linenr">13 </span><span style="color: #a1db00;">auto</span>&amp; <span style="color: #ff8700;">func2</span> = soneFunc;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">func2's type is void(&amp;)(int, double)</span>
</pre>
</div>

<p>
如你所见，auto类型推导与模板类型推导非常相似，它们恰如一枚银币的正反两面。
</p>

<p>
但有一个例外。我们将从以下情况开始慢慢分析：若用27初始化声明一个int变量，C++98有以下两种方式：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x3</span> = 27;
<span class="linenr">2 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x4</span>(27);
</pre>
</div>

<p>
C++11则提供了统一初始化<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>支持：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x3</span> = { 27 }:
<span class="linenr">2 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x4</span>{ 27 }:
</pre>
</div>

<p>
当然，这四行代码结果完全一样，它们都声明了一个初始值为27的整数。
</p>

<p>
正如<a href="./item5.html">条款5</a>所诉，用auto声明变量比通过写出确定的类型来声明变量更具优势，因此，在以上变量声明中，将int替换为auto是一个很明智的做法。替换后的声明如下：
</p>

<pre class="example">
auto x1 = 27;
auto x2(x1);
auto x3 = { 27 };
auto x4{ 27 };
</pre>

<p>
可是，替换后的声明虽然都能编译通过，却拥有了不同的含义。前两条语句依旧声明一个初始值为27的整数，但后两条语句声明的却是一个仅有一个元素（27）的std::initializer_list&lt;int&gt;！
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x1</span> = 27;           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is int, value is 27</span>
<span class="linenr">2 </span>
<span class="linenr">3 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x2</span>(27);            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">ditto</span>
<span class="linenr">4 </span>
<span class="linenr">5 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x3</span> = { 27 };       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is std::initializer_list&lt;int&gt;,</span>
<span class="linenr">6 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">value is { 27 }</span>
<span class="linenr">7 </span>
<span class="linenr">8 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x4</span>{ 27 };         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">ditto</span>
</pre>
</div>

<p>
这是由auto的一条特殊推导规则决定的。当一使用auto声明的变量使用初始化列表（被{}包围）进行初始化时，它将会被推导为std::initializer_list。如果该类型不能被推导（例如：初始化列表里的元素拥有不同的类型），代码将不能编译通过：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x5</span> = { 1, 2, 3.0 };  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">error! can't deduce T for</span>
<span class="linenr">2 </span>                          <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std::initializer_list&lt;T&gt;</span>
</pre>
</div>

<p>
正如注释所诉，类型推导将会失败，但重要的是，你必须意识到它其实触发了两条类型推导规则，其一是缘于auto的使用：由于x5使用了初始化列表，它必须被推导为std::initializer_list的一个实例，但std::initializer_list&lt;T&gt;是一个模板，这意味着编译器必须要推导T的类型。因此便触发了第二条类型推导规则。但由于初始化列表中的变量类型并不一致，推导失败。
</p>

<p>
在auto声明的变量中使用初始化列表，是auto类型推导与模板类型推导的唯一不同。此时该变量将会被推导为std::initializer_list。但将初始化列表传给一个模板函数却是一个错误的行为：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">x</span> = { 11, 23, 9 };    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">x's type is</span>
<span class="linenr">2 </span>                           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">std::initializer_list&lt;int&gt;</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">template with parameter</span>
<span class="linenr">5 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">declaration equivalent to</span>
<span class="linenr">6 </span>                           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">x's declaration</span>
<span class="linenr">7 </span>
<span class="linenr">8 </span>f({ 11, 23, 9});           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">error! can't deduce type for T</span>
</pre>
</div>

<p>
然而，如果将模板的参数声明为某一类型T的初始化列表（std::initializer_list&lt;T&gt;），模板类型推导规则将能正确的推导出T的类型：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">initialer_list</span>&lt;<span style="color: #00d7af;">T</span>&gt; <span style="color: #ff8700;">initList</span>);
<span class="linenr">3 </span>
<span class="linenr">4 </span>f({ 11, 23, 9});           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T deduced as int, and initList's</span>
<span class="linenr">5 </span>                           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is std::initializer_list&lt;int&gt;</span>
</pre>
</div>

<p>
所以，auto类型推导规则与模板类型推导规则唯一的区别便是，auto会将初始化列表推导为std::initializer_list，这是模板类型推导所不具备的能力。
</p>

<p>
你或许想知道为何auto类型推导会有这样一条模板类型推导所没有的特殊规则。虽然我也想知道，但遗憾的是，我自己也没有找的一个令人信服的解释。但规则就是规则，你必须要记住：
在用初始化列表初始化一个auto变量时，推导出的类型是std::initializer_list。特别是在你拥抱统一初始化哲学（将初始值用大括号扩起来）时，这点尤为重要。C++11中的一个常见错误就是意外的声明了一个std::initializer_list，这一陷阱导致许多程序员只在必要的时候才会使用大括号进行初始化。（我们将在<a href="./item7.html">条款7</a>中讨论何时必须使用大括号）
</p>

<p>
对于C++11的auto来说，已经没有什么规则可以讲述了，但在最新的C++14标准中，却还有内容需要补充。C++14允许使用auto关键字标明函数返回值需要被推导（参考<a href="./item3.html">条款3</a>），也允许在lambda函数中使用auto声明参数。然而，这些对于auto的特殊使用所触发的都是模板的类型推导，而不是auto类型推导。所以，在一个声明为auto返回值的函数中返回一个初始化列表将会编译失败：
</p>

<pre class="example">
auto createInitList()
{
    return { 1, 2, 3 };     // error: can't deduce type
                            // for { 1, 2, 3 }
}
</pre>

<p>
当然，向lambda函数的auto参数传递初始化列表，也不能编译通过：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">vector</span>&lt;<span style="color: #00d7af;">int</span>&gt; <span style="color: #ff8700;">v</span>;
<span class="linenr">2 </span>
<span class="linenr">3 </span><span style="color: #a1db00;">auto</span> <span style="color: #ff8700;">resetV</span> =
<span class="linenr">4 </span>    [&amp;v](<span style="color: #a1db00;">const</span> <span style="color: #a1db00;">auto</span>&amp; <span style="color: #ff8700;">newValue</span>) { v = newValue; }; <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">C++14</span>
<span class="linenr">5 </span>
<span class="linenr">6 </span>resetV({ 1, 2, 3 });       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">error! can't deduce type</span>
<span class="linenr">7 </span>                           <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">for { 1, 2, 3 }</span>
</pre>
</div>

<div id="outline-container-org021ce65" class="outline-2">
<h2 id="记住"><a id="org021ce65"></a>记住：</h2>
<div class="outline-text-2" id="text-记住">
<ul class="org-ul">
<li>auto类型推导通常与模板类型推导相同，但它拥有一个模板类型推导所不具备的能力：将初始化列表推导为std::initializer_list。</li>
<li>当auto作为函数的返回值或lambda的参数时，使用的是模板类型推导规则，而不是auto类型推导。</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
type specifier.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
universal reference.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
uniform initialization.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-07 Mon 14:22</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;
&lt;p&gt;
如果你已经阅读了&lt;a href=&quot;./item1.html&quot;&gt;条款1&lt;/a&gt;中关于模板类型推导相关的内容，你应该已经掌握了几乎所有的关于auto类型推导相关的知识，因为与模板类型推导规则相比，auto类型推导规则只有一个例外。这是为什么呢？因为模板类型推导涉及了模板、函数和参数，但auto并不关心那些东西。
&lt;/p&gt;

&lt;p&gt;
是的，但这无所谓。在模板类型推导与auto类型推导之间，有一个直接的映射，可以通过一种方法将他们互相转化。
&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="Effective Modern C++" scheme="http://paruka.me/categories/Translation/Effective-Modern-C/"/>
    
    
      <category term="Effective Modern C++" scheme="http://paruka.me/tags/Effective-Modern-C/"/>
    
      <category term="Press Ban" scheme="http://paruka.me/tags/Press-Ban/"/>
    
      <category term="禁止转载" scheme="http://paruka.me/tags/%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>条款1：理解模板类型推导</title>
    <link href="http://paruka.me/translation/effective_modern_cpp/item1.html"/>
    <id>http://paruka.me/translation/effective_modern_cpp/item1.html</id>
    <published>2016-10-08T15:29:00.000Z</published>
    <updated>2017-08-06T19:17:25.811Z</updated>
    
    <content type="html"><![CDATA[<div id="content">

<div id="outline-container-orgbdf6f5b" class="outline-2">
<h2 id="第一章-类型推导"><a id="orgbdf6f5b"></a>第一章 类型推导</h2>
<div class="outline-text-2" id="text-第一章-类型推导">
<p>
C++98有一套类型推导规则用于函数模板类型的推导。C++11对它稍作修改，并增加了两条： <b>auto</b> 和 <b>decltype</b> 。C++14扩展了 <b>auto</b> 和 <b>decltype</b> 的使用语境。类型推导的普遍应用，将你从手动拼写那些多余且明显的类型的繁重任务中解放出来，它让C++代码更加通用，它会自动的，将你对类型的修改传播到其他地方。当然，它也会让代码行为更难推测，毕竟编译器推导出的类型并不是一直都如你所料。
</p>
<a id="more"></a>

<p>
如果不能对类型推导有一个系统化的了解，就没法用现代的C++编写高效的代码，因为它几乎无处不在：函数模板调用、大多数auto出现的地方、decltype表达式，以及C++14中那奇妙的decltype(auto)构造函数。
</p>

<p>
这一章节讲述了一些类型推导知识，它们是每一名C++开发者都应掌握的内容。它解释了类型推导的工作原理，并告诉你auto和decltype是如何基于它构建自己的规则系统的。它也会教你如何强迫编译器推导出你所期望的类型结果。
</p>
</div>

<div id="outline-container-orgde9839c" class="outline-3">
<h3 id="条款1：理解模板类型推导"><a id="orgde9839c"></a>条款1：理解模板类型推导</h3>
<div class="outline-text-3" id="text-条款1：理解模板类型推导">
<p>
一些用户虽对某一复杂系统的工作原理及系统设计不甚了解，却仍能愉快的用它解决问题。遵循此道，C++中的模板类型推导不愧为一巨大的成功，不计其数的程序员，都曾通过调用模板函数获得了满意的结果，即便他们对模板类型推导规则不甚清楚。
</p>

<p>
如果你也是他们中的一员（曾从模板函数中受益的程序员），那我便有一好一坏两个消息要告诉你。好消息是，模板类型推导是构成C++中最引人入胜的新特性 <b>auto</b> 的基础。如果你对C++98的模板类型推导较为熟悉，那么你也已经对C++11的 <b>auto</b> 推导规则有了大概的了解，坏消息是， <b>auto</b> 中的类型推导，很多时候并不像模板类型推导那么直白，因此，对模板类型推导有个全面细致的了解，就显得尤为重要。这条条款将为你详细叙述。
</p>

<p>
如果你不介意使用部分伪代码，我们便可将一函数模板描述如下：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">ParamType</span> <span style="color: #ff8700;">param</span>);
</pre>
</div>

<p>
对它的调用看起来是这样的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span>f(expr); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">call f with some expression</span>
</pre>
</div>

<p>
在编译时，编译器使用 <i>expr</i> 来推导两个类型： <b>T</b> 和 <b>ParamType</b> <sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>，它们通常并不相同， <b>ParamType</b> 经常会包含一些类似于const或引用限定之类的修饰符。比如，一模板声明如下：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">T</span>&amp; <span style="color: #ff8700;">param</span>); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">ParamType is const T&amp;</span>
</pre>
</div>

<p>
调用如下：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x</span> = 0;
<span class="linenr">2 </span>f(x); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">call f with an int</span>
</pre>
</div>

<p>
T被推导为int，但ParamType被推导为const int&amp;。
</p>

<p>
我们很自然的会认为，T应该被推导为传入的实参类型，即expr的类型。以上例子便是如此：x为int，T也被推导为int。但事实却并非如此，T类型的推导，并不完全取决于expr，它通常也跟ParamType有关。可总结为三种情况：
</p>

<ul class="org-ul">
<li><b>ParamType</b> 是指针或引用，但不是通用引用<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>(universal reference)。（universal reference将在<a href="./item24.html">条款24</a>中详细讲述。再此你只需要知道它确实存在，且与左值引用和右值引用不同即可。）</li>
<li><b>ParamType</b> 是一个通用引用（universal reference）。</li>
<li><b>ParamType</b> 既不是指针，也不是引用。</li>
</ul>

<p>
因此，我们将对三种情形分别进行讲述，每一情形都将使用如下例子：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">ParamType</span> <span style="color: #ff8700;">param</span>);
<span class="linenr">3 </span>
<span class="linenr">4 </span>f(expr); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">deduce T and ParamType from expr</span>
</pre>
</div>
</div>

<div id="outline-container-orgf40a164" class="outline-4">
<h4 id="情形1-paramtype是一个引用或指针但不是通用引用universal-reference"><a id="orgf40a164"></a>情形1: ParamType是一个引用或指针，但不是通用引用（universal reference）</h4>
<div class="outline-text-4" id="text-情形1-paramtype是一个引用或指针但不是通用引用universal-reference">
<p>
最简单的情况就是， <b>ParamType</b> 是一个引用或指针，但不是通用引用（universal reference）。此时的类型推导将遵循如下步骤：
</p>

<ol class="org-ol">
<li>如果 <i>expr</i> 的类型是一个引用，忽略引用部分。</li>
<li>用 <i>expr</i> 的类型来匹配ParamType并决定出T的类型。</li>
</ol>

<p>
例如，针对模板：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>&amp; <span style="color: #ff8700;">param</span>); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Param is a reference</span>
</pre>
</div>

<p>
我们定义如下类型：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x</span> = 27;         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">x is an int</span>
<span class="linenr">2 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">cx</span> = x;   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">cx is a const int</span>
<span class="linenr">3 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span>&amp; <span style="color: #ff8700;">rx</span> = x;  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rx is a reference to x as a const int</span>
</pre>
</div>

<p>
对于以下调用，param及T的类型推导如注释所诉：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span>f(x);       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is int, Param's type is int&amp;</span>
<span class="linenr">2 </span>
<span class="linenr">3 </span>f(cx);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is const int,</span>
<span class="linenr">4 </span>            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Param's type is const int&amp;</span>
<span class="linenr">5 </span>
<span class="linenr">6 </span>f(rx);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is const int,</span>
<span class="linenr">7 </span>            <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">Param's type is const int&amp;</span>
</pre>
</div>

<p>
在第二、三个调用中，由于cx和rx都是const变量，T便被推导为const int，因此ParamType是const int&amp;。这对调用者非常重要，因为当一个const对象被传递给一个引用参数时，函数的调用者自然会期望这个对象在函数内不能被修改，这便是一个指向常量的引用。因此，向一个模板的T&amp;参数传递一个const对象是安全的：对象的const属性会被推导为T的一部分。
</p>

<p>
在第三个调用中，需要注意的是，虽然rx的类型是一个引用，T仍然被推导为非引用类型。这是因为在类型推导中，rx的引用属性被忽略了。
</p>

<p>
上面的例子讲诉的都是左值引用，不过这些推导规则与右值引用完全一致。虽然只有右值才能被传递给右值引用类型的参数，但这一限制与类型推导规则毫不相关。
</p>

<p>
如果我们将f的参数类型由T&amp;修改为const T&amp;，推导规则将会发生细微的变化，cx和rx的常量性依旧保留，但因为Param的类型是一个常量引用，T的const修饰符便不再需要了：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #a1db00;">const</span> <span style="color: #00d7af;">T</span>&amp; <span style="color: #ff8700;">param</span>); <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is now a ref-to-const</span>
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x</span> = 27;             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 5 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">cx</span> = x;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 6 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span>&amp; <span style="color: #ff8700;">rx</span> = x;      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 7 </span>
<span class="linenr"> 8 </span>f(x);                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is int, param's type is const int&amp;</span>
<span class="linenr"> 9 </span>
<span class="linenr">10 </span>f(cx);                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is int, param's type is const int&amp;</span>
<span class="linenr">11 </span>
<span class="linenr">12 </span>f(rx);                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is int, param's type is const int&amp;</span>
</pre>
</div>

<p>
与之前的例子一样，rx的引用属性在推导过程中被忽略了。
</p>

<p>
当param为指针（或常量指针）时，推导规则与引用一致：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>* <span style="color: #ff8700;">param</span>);        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is now a pointer</span>
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x</span> = 27;              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 5 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span>* <span style="color: #ff8700;">px</span> = &amp;x;      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">px is a ptr to x as a const int</span>
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span>f(&amp;x);                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is int, param's type is int*</span>
<span class="linenr"> 8 </span>
<span class="linenr"> 9 </span>f(px);                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T is const int,</span>
<span class="linenr">10 </span>                         <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param's type is const int*</span>
</pre>
</div>

<p>
至此，你可能会感到有点无聊，因为C++的类型推导规则对引用和指针来说是如此的自然，它与你的设想完全一致。
</p>
</div>
</div>

<div id="outline-container-org584fae7" class="outline-4">
<h4 id="情形2: ParamType是一个通用引用（universal reference）"><a id="org584fae7"></a>情形2: ParamType是一个通用引用（universal reference）</h4>
<div class="outline-text-4" id="text-情形2: ParamType是一个通用引用（universal reference）">
<p>
当模板参数类型为通用引用时，规则就变得有点复杂了。通用引用参数（universal reference parameters）以右值引用的形式声明（例如：对于类型T，通用引用被声明为T&amp;&amp;），它们在被传入左值时，会有不一样的表现。详细情况我们会在<a href="./item24.html">条款24</a>中讲诉，在此只做简要概述：
</p>

<ul class="org-ul">
<li>如果 <i>expr</i> 为左值，T和ParamType都会被推导为左值引用。这有两个不寻常点。第一，这是唯一一种T被推导为引用的情况。第二，虽然ParamType被声明为右值引用，它却被推导为一个左值引用。</li>
<li>如果 <i>expr</i> 为右值，推导规则如情形1所诉。</li>
</ul>

<p>
例如：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>&amp;&amp; <span style="color: #ff8700;">param</span>);      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is now a universal reference</span>
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x</span> = 27;             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 5 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">cx</span> = x;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 6 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span>&amp; <span style="color: #ff8700;">rx</span> = x;      <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr"> 7 </span>
<span class="linenr"> 8 </span>f(x);                   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">x is lvalue, so T is int&amp;,</span>
<span class="linenr"> 9 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param's type is also int&amp;</span>
<span class="linenr">10 </span>
<span class="linenr">11 </span>f(cx);                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">cx is lvalue, so T is const int&amp;,</span>
<span class="linenr">12 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param's type is also const int&amp;</span>
<span class="linenr">13 </span>
<span class="linenr">14 </span>f(rx);                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">rx is lvalue, so T is const int&amp;,</span>
<span class="linenr">15 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param's type is also const int&amp;&#728;</span>
<span class="linenr">16 </span>
<span class="linenr">17 </span>f(27);                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">27 is rvalue, so T is int,</span>
<span class="linenr">18 </span>                        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param's type is therefore int&amp;&amp;</span>
</pre>
</div>

<p>
<a href="./item24.html">条款24</a>将对以上例子进行详细解释，这里只需要记住：通用引用的类型推导规则与左、右值引用并不相同，它与传入参数的类型（是左值或右值）有关，这与非通用引用（non-universal references）完全不同。
</p>
</div>
</div>

<div id="outline-container-org86774a1" class="outline-4">
<h4 id="情形3: ParamType既不是引用也不是指针"><a id="org86774a1"></a>情形3: ParamType既不是引用也不是指针</h4>
<div class="outline-text-4" id="text-情形3: ParamType既不是引用也不是指针">
<p>
当ParamType既不是引用也不是指针时，我们将它按照值传递的方式处理：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">tamplate</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> f(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is now passed by value</span>
</pre>
</div>

<p>
这意味着Param将会是实参的一个拷贝：一个全新的对象。事实上，也正是这一现象（param将会成为一个新对象）直接导致了T的推导规则必须遵循如下规定：
</p>

<ol class="org-ol">
<li>与之前一样，如果 <i>expr</i> 的类型是一个引用，则忽略引用属性。</li>
<li>忽略引用属性后，如果 <i>expr</i> 带有 <b>const</b> 或 <b>volatile</b> 属性，一并忽略。（volatile属性的对象并不常见，它们通常只会在实现设备驱动程序时使用。详情参考<a href="./item40.html">条款40</a>。）</li>
</ol>

<p>
因此：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">x</span> = 27;             <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr">2 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span> <span style="color: #ff8700;">cx</span> = x;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr">3 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">int</span>&amp; <span style="color: #ff8700;">rx</span>= x;       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">as before</span>
<span class="linenr">4 </span>
<span class="linenr">5 </span>f(x);                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T's and param's types are both int</span>
<span class="linenr">6 </span>f(cx);                 <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T's and param's types are again both int</span>
<span class="linenr">7 </span>f(rx);                 <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">T's and param's types are still both int</span>
</pre>
</div>

<p>
注意，即便cx和rx都是const变量， <i>param</i> 的类型却不是const。这是有道理的： <i>param</i> 是与它的实参（cx或rx）完全独立的、全新的对象，是实参（cx或rx）的拷贝，因此，实参（cx或rx）不能被修改这样的限制对param完全无效。这就是为什么 <i>expr</i> 的const属性在param的类型推导过程中会被忽略（volatile属性同理）： <i>expr</i> 不能被修改并不意味着它的拷贝不能被修改。
</p>

<p>
const和volatile属性只有在值传递时才会被忽略，这点非常重要。正如之前所诉，在推导形参为指向常量的引用或指针时， <i>expr</i> 的const属性是不会被忽略的。但当 <i>expr</i> 是一个指向常量的常指针时，将它以值传递方式传递给以下模板会怎样呢？
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);                              <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param is still passed by value</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span>* <span style="color: #a1db00;">const</span> <span style="color: #ff8700;">ptr</span> = <span style="color: #ff4ea3;">"Fun with pointers"</span>;  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">ptr is const pointer to const object</span>
<span class="linenr">5 </span>
<span class="linenr">6 </span>f(ptr);                                       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">pass arg of type const char * const</span>
</pre>
</div>

<p>
星号右边的const声明了ptr是一个const变量：ptr不能被指向其它的地方，也不能被设置为null。（星号左边的const表明指向的字符串是常量，该字符串不能被修改。）当ptr被传递给f时，它被按位拷贝给param，因此， <i>指针自己（ptr）是按值传递的</i> 。根据值传递的推导规则，ptr的const属性将会被忽略，param的类型被推导为const char*，即一个可被修改的指向const字符串的指针（指针的指向可被修改，但其指向的内容不能被修改）。ptr指向的内容的const属性在推导过程中被保留了，但ptr自己的const属性在拷贝生成一个新指针（param）时，被忽略了。
</p>
</div>
</div>
<div id="outline-container-org786f390" class="outline-4">
<h4 id="数组实参"><a id="org786f390"></a>数组实参</h4>
<div class="outline-text-4" id="text-数组实参">
<p>
之前所诉已是模板推导的主流情形，但还有一个较为罕见的情形需要我们了解：数组与指针其实是不同的，尽管它们大多数情况下可以相互替换使用。数组在很多情况下会退化为指向它第一个元素的地址的指针，这给许多人造成了"数组与指针是一样的"这样的错觉。这种数组到指针的退化，让以下代码变得合法：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span> <span style="color: #ff8700;">name</span>[] = <span style="color: #ff4ea3;">"J. P. Briggs"</span>;  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">name's type is</span>
<span class="linenr">2 </span>                                     <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">const char[13]</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span><span style="color: #a1db00;">const</span> <span style="color: #00d7af;">char</span>* <span style="color: #ff8700;">ptrToName</span> = name;        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">array decays to pointer</span>
</pre>
</div>

<p>
const char* 指针ptrToName被const char[13]类型的变量name初始化，它们的类型（const char* 和const char[13]）并不相同，但因这条数组指针退化规则（array-to-pointer）的存在，以上代码可以编译通过。
</p>

<p>
但当数组以值传递的方式被传给模板时又会怎样呢？
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);        <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">template with by-value parameter</span>
<span class="linenr">3 </span>
<span class="linenr">4 </span>f(name);                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">what types are deduced for T and param?</span>
</pre>
</div>

<p>
我们首先应该注意到函数是没有数组类型的参数的。是的，是的，以下语法确实是合法的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">myFunc</span>(<span style="color: #00d7af;">int</span> <span style="color: #ff8700;">param</span>[]);
</pre>
</div>

<p>
但是，数组声明被当成了指针，也就是说myFunc其实和以下声明是一样的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">myFunc</span>(<span style="color: #00d7af;">int</span>* <span style="color: #ff8700;">param</span>);  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">same function as above</span>
</pre>
</div>

<p>
这种数组与指针参数的等价继承自C++的父亲C，它给人一种数组与指针相同的错觉。
</p>

<p>
由于数组参数被当成指针参数对待，以值方式传入模板的数组会被推导为指针，因此对于模板函数f的调用，T被推导为const char*：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span>f(name);                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">name is array, but T deduced as const char*</span>
</pre>
</div>

<p>
但出乎意料的是，尽管函数不能声明真正的数组参数，它们却可以声明指向数组的引用作为自己的参数！所以如果我们把模板f修改为接收一个引用作为参数，
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr">2 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f</span>(<span style="color: #00d7af;">T</span>&amp; <span style="color: #ff8700;">param</span>);       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">template with by-reference parameter</span>
</pre>
</div>

<p>
并向其传入一个数组，
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span>f(name);                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">pass array of f</span>
</pre>
</div>

<p>
T真的会被推导为数组类型！该类型包含了被传入的数组的大小，针对此例，T被推导为const char[13]，f的参数（指向这个数组的引用）类型为const char (&amp;)[13]。确实，这语法难以理解，但与掌握它所给予你能力的提高相比，消耗的那点精力简直微不足道（Yes, the syntax looks toxic（这语法有毒！）, but knowing it will score you mondo points with those few souls who care.）。
</p>

<p>
有趣的是，我们可以利用这一技巧（声明指向数组的引用）创建一个模板来推导数组元素的个数。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#22312;&#32534;&#35793;&#26399;&#36820;&#22238;&#25351;&#23450;&#25968;&#32452;&#30340;&#38271;&#24230;&#12290;</span>
<span class="linenr">2 </span><span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">&#65288;&#25968;&#32452;&#24418;&#21442;&#26159;&#19968;&#20010;&#21311;&#21517;&#21442;&#25968;&#65292;&#22240;&#20026;&#25105;&#20204;&#21482;&#20851;&#24515;&#23427;&#25317;&#26377;&#30340;&#20803;&#32032;&#20010;&#25968;&#65289;</span>
<span class="linenr">3 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>, <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">size_t</span> <span style="color: #ff8700;">N</span>&gt;
<span class="linenr">4 </span><span style="color: #a1db00;">constexpr</span> <span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">size_t</span> <span style="color: #ffd700;">arraySize</span>(<span style="color: #00d7af;">T</span> (&amp;)[N]) noexpect
<span class="linenr">5 </span>{
<span class="linenr">6 </span>    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">see info below on constexpr and noexcept</span>
<span class="linenr">7 </span>    <span style="color: #a1db00;">return</span> N;
<span class="linenr">8 </span>}
</pre>
</div>

<p>
正如<a href="./item15.html">条款15</a>所诉，将此函数声明为constexpr将使其结果在编译时被计算。这使得我们可以声明一个其元素个数与某一使用大扩号方式初始化的数组的元素个数相同的数组：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">keyValues</span>[] = {1, 3, 7, 9, 11, 22, 35};   <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">keyValue has 7 elements</span>
<span class="linenr">2 </span>
<span class="linenr">3 </span><span style="color: #00d7af;">int</span> <span style="color: #ff8700;">mappedVals</span>[arraySize(keyValue)];          <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">so does mappedVals</span>
</pre>
</div>

<p>
当然，作为一名现代化的C++程序员，你应当很自然的选择使用std:array代替内置的数组：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1 </span><span style="color: #5fafd7;">std</span>::<span style="color: #00d7af;">array</span>&lt;<span style="color: #00d7af;">int</span>, arraySize(keyValue)&gt; <span style="color: #ff8700;">mappedVals</span>;  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">mappedVals' size is 7</span>
</pre>
</div>

<p>
将arraySize声明为noexcept，将使编译器更易于生成更好的代码。详请请看<a href="./item14.html">条款14</a>。
</p>
</div>
</div>

<div id="outline-container-org6943035" class="outline-4">
<h4 id="函数实参"><a id="org6943035"></a>函数实参</h4>
<div class="outline-text-4" id="text-函数实参">
<p>
数组并不是C++中唯一一种会退化为指针的东西。函数也会退化为函数指针，并且我们之前所讨论的数组类型推导的规则对于函数类型推导依旧适用。因此：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">someFunc</span>(<span style="color: #00d7af;">int</span>, <span style="color: #00d7af;">double</span>);       <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">someFunc is a function;</span>
<span class="linenr"> 2 </span>                                  <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is void(int, double)</span>
<span class="linenr"> 3 </span>
<span class="linenr"> 4 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 5 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f1</span>(<span style="color: #00d7af;">T</span> <span style="color: #ff8700;">param</span>);                <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">in f1, param passed by value</span>
<span class="linenr"> 6 </span>
<span class="linenr"> 7 </span><span style="color: #a1db00;">template</span>&lt;<span style="color: #a1db00;">typename</span> <span style="color: #00d7af;">T</span>&gt;
<span class="linenr"> 8 </span><span style="color: #00d7af;">void</span> <span style="color: #ffd700;">f2</span>(<span style="color: #00d7af;">T</span>&amp; <span style="color: #ff8700;">param</span>);               <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">in f2, param passed by ref</span>
<span class="linenr"> 9 </span>
<span class="linenr">10 </span>f1(someFunc);                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param deduced as ptr-to-func;</span>
<span class="linenr">11 </span>                                 <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is void (*)(int, double)</span>
<span class="linenr">12 </span>
<span class="linenr">13 </span>f2(someFunc);                    <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">param deduced as ref-to-func;</span>
<span class="linenr">14 </span>                                 <span style="color: #6c6c6c; font-style: italic;">// </span><span style="color: #6c6c6c; font-style: italic;">type is void (&amp;)(int, double)</span>
</pre>
</div>

<p>
它们（推导为函数指针与推导为函数引用）在使用中没有任何不同，但如果你正在学习数组到指针的退化规则，你应该也要顺道学习以下函数到指针的退化规则。
</p>

<p>
现在你已经知道了模板类型推导规则，我在条款开始的时候便说，它极其简单，事实上，它大多数时候都很简单。当然，通用引用（universal reference）传入左值实参时可能会略显复杂，还有数组和函数到指针的退化这条规则，可能会让你感到混乱。许多时候，你可能会想”抓住编译器的衣领“向它查问，"告诉我你推导出什么类型！"，那时你就应该转到<a href="./item4.html">条款4</a>，它会告诉你如何诱导编译器这么做。
</p>
</div>
</div>

<div id="outline-container-org923dba4" class="outline-4">
<h4 id="记住"><a id="org923dba4"></a>记住：</h4>
<div class="outline-text-4" id="text-记住">
<ul class="org-ul">
<li>在模板类型推导过程中，引用实参会被当成非引用实参对待，也就是说实参的引用属性被忽略了。</li>
<li>当模板参数（形参）为通用引用时，左值实参需要特殊对待。</li>
<li>在推导值传递形参的模板时，实参的const和volatile属性被移除。</li>
<li>在推导过程中，数组和函数实参都会被退化为指针，除非它们被用来初始化引用（形参为引用时便是这种情况）。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
parameter翻译为形参，argument翻译为实参。本文中的参数一概指形参，在易混淆的地方，会指明是形参或实参。
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
universal reference。
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div style="font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;">Last Updated <b>2017-08-07 Mon 14:22</b>. <br><a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.2.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 9.0.9)</div>
</div>
]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;content&quot;&gt;

&lt;div id=&quot;outline-container-orgbdf6f5b&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;第一章-类型推导&quot;&gt;&lt;a id=&quot;orgbdf6f5b&quot;&gt;&lt;/a&gt;第一章 类型推导&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-第一章-类型推导&quot;&gt;
&lt;p&gt;
C++98有一套类型推导规则用于函数模板类型的推导。C++11对它稍作修改，并增加了两条： &lt;b&gt;auto&lt;/b&gt; 和 &lt;b&gt;decltype&lt;/b&gt; 。C++14扩展了 &lt;b&gt;auto&lt;/b&gt; 和 &lt;b&gt;decltype&lt;/b&gt; 的使用语境。类型推导的普遍应用，将你从手动拼写那些多余且明显的类型的繁重任务中解放出来，它让C++代码更加通用，它会自动的，将你对类型的修改传播到其他地方。当然，它也会让代码行为更难推测，毕竟编译器推导出的类型并不是一直都如你所料。
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Translation" scheme="http://paruka.me/categories/Translation/"/>
    
      <category term="Effective Modern C++" scheme="http://paruka.me/categories/Translation/Effective-Modern-C/"/>
    
    
      <category term="Effective Modern C++" scheme="http://paruka.me/tags/Effective-Modern-C/"/>
    
      <category term="Press Ban" scheme="http://paruka.me/tags/Press-Ban/"/>
    
      <category term="禁止转载" scheme="http://paruka.me/tags/%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
