<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[use of constexpr in header file]]></title>
    <url>%2Ftranslation%2Fstackoverflow%2Fuse-of-constexpr-in-header-file.html</url>
    <content type="text"><![CDATA[翻译自 stackoverflow 。 我能在头文件中这样定义变量吗？ 1 constexpr double PI=3.14; 当我在多个cpp文件中包含这个头文件时，会有什么问题？ 我对此有点担心，因为C++标准里说constexpr有它自己的内存，因此在头文件中使用它，并将其引用至多个cpp文件会在内存中生成该值的多份拷贝。标准里还提到了许多我无法理解的内容。 我使用的是C++11。 Answer #1 constexpr 意指 const ，而 const 在全局及名字空间作用域内意指 static （内部链接），这意味着每一个包含有该头文件的编译单元都有一份 PI 的拷贝。该内存仅在取其地址（访问该变量）或引用时才会申请，且各编译单元内的地址均不相同。 const 变量意为 static 这一规则的引入，明确了在C++头文件中使用 const 取代 #define 定义常量这一方式。（若 const 变量）没有 static 语义，在链接包含有该头文件的多个编译单元时，会发生 符号重复定义 的链接错误。 在C++17中，你可以声明它为 inline ，这样在使用它时，内存中只会存有一份 PI （与 static 不同）。C++17引入 inline 变量，使得在header-only库中定义非常量变量成为可行。注意， constexpr 修饰静态数据成员时已有 inline 之意，无需显示使用 inline 。 综上所述，你应该在头文件中尽可能的使用 constexpr 定义常量，若不可行，转用 const 。并在需要的情况下，使用 inline 确保其内存唯一。 #2 你已经很清楚在 C++17 中该怎么做了。在 C++11 中，你可以将它封装为一个函数： 1 constexpr double PI () { return 3.14; } Last Updated 2018-07-23 Mon 00:01. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Why C++11 in-class initializer cannot use parentheses?]]></title>
    <url>%2Ftranslation%2Fstackoverflow%2Fwhy-c11-in-class-initializer-cannot-use-parentheses.html</url>
    <content type="text"><![CDATA[翻译自 stackoverflow。 比如，你不能这样写： 1 class A 2 { 3 vector&lt;int&gt; v(12, 1); 4 }; 只能这样写： 1 class A 2 { 3 vector&lt;int&gt; v1{ 12, 1 }; 4 vector&lt;int&gt; v2 = vector&lt;int&gt;(12, 1); 5 }; 对于它们的区别，C++11在设计层面上是怎样考虑的呢？ Answer 可能是因为在这种情况下使用括号初始化会将我们引入混乱之中(most vexing parse)。 1考虑如下两个类型： 1 struct foo {}; 2 struct bar 3 { 4 bar(foo const&amp;) {} 5 }; 现在，你有一个 bar 类型的数据成员需要初始化，因此，你这样定义它 1 struct A 2 { 3 bar B(foo()); 4 }; 但这样做只是声明了一个名为 B 的函数，它按值返回一 bar 类型的对象，且拥有一署名为 foo() 样式的函数作为参数（返回一个 foo 类型的对象，且不接收任何参数）。 由stackoverflow中这一问题被提及的频率可知，这是大多数C++程序员感到困惑、不解的地方。引入新的大括号初始化及等号初始化语法为避免这一混淆提供了锲机，这大概就是C++标准委员会这样做的原因。 1 bar B{foo{}}; 2 bar B = foo(); 上面的两种方式，均声明了一名为 B 的 bar 类型对象。 撇开之前的猜测，我需要指出的是，你在你给出的例子中做了两件截然不同的事情。 1 vector&lt;int&gt; v1{ 12, 1 }; 2 vector&lt;int&gt; v2 = vector&lt;int&gt;(12, 1); 第一行代码初始化了一个 vector v1 ，它包含了两个元素, 12 和 1 。第二行代码创建了一个 vector v2 ，它有 12 个元素，且每个元素的值均为 1 。 记住这一规则：如果某一类型定义了初始化列表构造函数（接收 std::initialer_list&lt;T&gt; 作为参数的构造函数），那么在使用大括号初始化构造该对象时，它总是被优先匹配。其它的构造函数仅在 initialer_list 构造函数不可用时才被选用。 Footnotes: 1 Scott Meyers 在《Effective STL》中称其为 C++'s most vexing parse ，翻译为 “C++最令人费解的解析” 。 Last Updated 2018-07-08 Sun 02:23. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>stackoverflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top-level const与low-level const]]></title>
    <url>%2Fstudy_notes%2Fcc%2Ftop_level_const.html</url>
    <content type="text"><![CDATA[Stanley B. Lippman 在其传世名作 《C++ Primer》中对它们定义如下： As we’ve seen, a pointer is an object that can point to a different object. As a result,we can talk independently about whether a pointer is const and whether the object to which it can point are const. We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. 大意是：本身为const的指针称为 top-level const ，指向的内容为const的指针为 low-level const 。 stackoverflow上有一个很好的解答： A top-level const qualifier affects the object itself. Others are only relevant with pointers and references. They do not make the object const, and only prevent modification through a path using the pointer or reference. Thus: char x; char const* p = &amp;x; This is not a top-level const, and none of the objects are immutable. The expression *p cannot be used to modify x, but other expressions can be; x is not const. For that matter *const_cast&lt;char*&gt;( p ) = 't' is legal and well defined. But char const x = 't'; char const* p = &amp;x; This time, there is a top-level const on x, so x is immutable. No expression is allowed to change it (even if const_cast is used). The compiler may put x in read-only memory, and it may assume that the value of x never changes, regardless of what other code may do. To give the pointer top-level const, you'd write: char x = 't'; char *const p = &amp;x; In this case, p will point to x forever; any attempt to change this is undefined behavior (and the compiler may put p in read-only memory, or assume that *p refers to x, regardless of any other code). 大概翻译一下： top-level const 限定符影响的是对象本身。另一个只与指针和引用相关。它们（指针和引用）并不能使对象变为常量，只是阻止使用该指针或引用修改此对象的值： char x; char const* p = &amp;x; 这并不是一个 top-level const ，且没有一个对象是不可变的，你无法使用表达式 *p 修改 x 的值，却可以使用别的表达式达到这一目的； x 并不是常量。因此： *const_cast&lt;char*&gt;( p ) = 't' 是合法且语义清晰的。 但 char const x = 't'; char const* p = &amp;x; 有一个作用与 x 的 top-level const 限定符，所以 x 是不可变的。没有任何表达式可以修改它（哪怕是 const_cast ）。编译器将 x 放至只读内存中，并认为 x 的值绝对不会发送改变，无论代码对它做任何操作。 赋予一个指针 top-level const 限定符，你可以这样写： char x = 't'; char *const p = &amp;x; 此时， p 将永远指向 x ；任何企图修改其指向的行为都是未定义的（且编译器会将 p 存放至只读内存中，或假定 *p 便是 x ，不管其它代码有何企图）。 Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Study Notes</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款33：在对auto&&参数执行std::forward时使用decltype]]></title>
    <url>%2Ftranslation%2Feffective_modern_cpp%2Fitem33.html</url>
    <content type="text"><![CDATA[C++14 中最令人兴奋的特性之一便是 泛型lambda ──可用 auto 声明lambda函数的参数。这一特性的实现很直白：将该lambda闭包类的 operator() 实现为一模板。以如下 lambda 为例： 1 auto f = [](auto x) { return func(normalize(x)); }; 其闭包类的函数调用操作符大致如下： 1 class SomeCompilerGeneratedClassName { 2 public: 3 template &lt;typename T&gt; // see Item 3 for 4 auto operator ()(T x) const // auto return type 5 { return func(normalize(x)); } 6 7 ... // other closure class 8 }; // functionality 此例中， lambda 所做的事情仅仅是将参数 x 转发给 normalize 。如果 normalize 区分左右值，此lambda便是错误的，因为它总是传递一左值（参数 x ）给 normalize ，即便它的实参是一个右值。 该 lambda 的正确写法是将其参数 x 完美转发给 normalize 。因此需对代码做两个修改。第一，将 x 改为通用引用（参考 条款24），第二，使用 std::forward 将 x 转发给 normalize （参考条款25），大概如下，都是一些琐碎的修改： 1 auto f = [](auto&amp;&amp; x) 2 { return func(normalize(std::forward&lt;???&gt;(x))); }; 在大概与现实之间，有一个问题夹杂其中：传递给 std::forward 的应该是什么类型，以上代码的 ??? 部分该如何编写？ 通常，在使用完美转发时，你正处于一类型参数为 T 的模板函数之中，因此，只需编写 std::forward&lt;T&gt; 即可。但在泛型lambda中并没有类型参数 T 。 T 只存在于由此 lambda 函数生成的闭包类的模板化 operator() 函数中，可我们无法在lambda函数中引用它，因此，它毫无作用。 条款28讲道，对于通用引用类型的形参，传入左值实参，则形参类型为左值引用；传入右值实参，则形参类型为右值引用。这意味着在lambda函数中，我们可以通过检查形参 x 的类型来判断传入的实参是左值还是右值。 decltype 给予了我们这一能力（参考条款3）。如果传入的是左值， decltype(x) 将产生一左值引用 类型 。如果传入的是右值， decltype(x) 将产生一右值引用 类型 。 条款28同样讲到，在调用 std::forward 时，规定：传入的类型参数为左值引用时返回一左值，非引用类型则返回一右值。在我们的lambda函数中，若 x 绑定至左值， decltype(x) 将产生一左值引用。这是符合规则的。但当 x 绑定至右值时， decltype 将产生一右值引用，而不是非引用类型。 回看条款28给出的 std::forward 的 C++14 实现： 1 template&lt;typename T&gt; // in namespace 2 T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; param) // std 3 { 4 return static_cast&lt;T&amp;&amp;&gt;(param); 5 } 如果客户代码想要完美转发一 Widget 类型的右值，它通常会用 Widget 类型（既非引用类型）实例化 std::forward ，所以 std::forward 模板生成如下函数： 1 Widget&amp;&amp; forward(Widget&amp; param) // instantiation of 2 { // std::forward when 3 return static_cast&lt;Widget&amp;&amp;&gt;(param); // T is Widget 4 } 但考虑一下，若客户代码想完美转发该 Widget 类型的右值，却没有遵循指定 T 为非引用类型的规定，而是将其设为右值引用，会发生什么。想象一下 T 为 Widget&amp;&amp; 。 在实例化 std::forward 并调用 std::remove_reference_t 之后，引用折叠（再次参考条款28）触发之前， std::forward 看起来会是这样的： 1 Widget&amp;&amp; &amp;&amp; forward(Widget&amp; param) // instantiation of 2 { // std::forward when 3 return static_cast&lt;Widget&amp;&amp; &amp;&amp;&gt;(param); // T is Widget&amp;&amp; 4 } // (before reference- 5 // collapsing) 应用引用折叠规则 —— 右值引用的右值引用为一右值引用（简单理解为&amp;&amp; + &amp;&amp; = &amp;&amp;） 之后，真相便浮出水面： 1 Widget&amp;&amp; forward(Widget&amp; param) // instantiation of 2 { // std::forward when 3 return static_cast&lt;Widget&amp;&amp;&gt;(param); // T is Widget&amp;&amp; 4 } // (after reference- 5 // collapsing) 如果你把该实例化版本与 T 为 Widget 的那个 std::forward 实例化版本相比较，你会发觉它们是相同的。这意味着用右值引用实例化 std::forward 与用非引用类型实例化它是一样的结果。 这是极好的，因为当将一右值传递给lambda函数的形参 x 时， decltype(x) 将生成一右值引用类型。我们在上面已经确认，当传入一左值给lambda时， decltype(x) 会生成一常规类型传递给 std::forward ，而现在我们知道，对于右值 decltype(x) 生成的传递给 std::forward 的类型是非常规的，但结果却与常规类型相同。所以，无论是左值还是右值，将 decltype(x) 传递给 std::forward 都能得到我们期望的结果。因此，我们的完美转发lambda便是这是编写的： 1 auto f = 2 [](auto&amp;&amp; param) 3 { 4 return 5 func(normalize(std::forward&lt;decltype(param)&gt;(param))); 6 }; 对它稍作修改，只需6个点号，便可接受任意个数的参数1，因为 C++14 的lambda可以是变参的： 1 auto f = 2 [](auto&amp;&amp;... params) 3 { 4 return 5 func(normalize(std::forward&lt;decltype(param)&gt;(params)...)); 6 }; 记住 在对 auto&amp;&amp; 参数执行 std::forward 时使用 decltype 。 Footnotes: 1 From there, it's just a hop, skip, and six dots to a perfect-forwarding lambda that accepts not just a single paramater, but any number of parameters. 这里 a hop,skip and jump 是三级跳的意思 第一步小 第二步大 第三步更大,所以也有势头越来越猛,速度越来越快的意思 Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
        <tag>Press Ban</tag>
        <tag>禁止转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lab 0：环境搭建]]></title>
    <url>%2Fstudy_notes%2Focw%2Fmit%2F6.828%2Flab_0.html</url>
    <content type="text"><![CDATA[简介 mit 6.828是一门广受好评的操作系统课程，它秉承实践为主的理念，通过设计并实现一unix-like操作系统，加深学习者对操作系统的理解。本文将遵循Lab 1: Booting a PC的指引，完成学习环境的搭建，为后续学习做好准备。 事实上，本文内容源于Lab 1: Booting a PC，本应与下一篇学习笔记一起，探讨计算机的启动流程，但因本人太懒，还是分成两篇博文讲解吧。 Lab 1是该课程的第一个练习，目的是介绍x86汇编以及PC的启动流程，因此，需要QEMU及QEMU/GDB进行协调调试。关于x86汇编相关知识，Lab 1: Booting a PC中给予了很多学习资料，在此便不再废话了，本文只会记录学习环境的搭建过程。 思路 此课程使用QEMU模拟x86计算机，并用GDB对系统进行跟踪调试。因此，我创建了一docker镜像，于镜像中安装QEMU及GDB，并开放22端口，方便通过ssh进入容器开始调试。 Dockerfiles 首先当然是要下载QEMU及JOS源码了（注意，下载速度 超慢 ，建议翻墙。）： 1 git clone git://git.qemu-project.org/qemu.git source 2 git clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab 因对debian系较为熟悉，我使用了ubuntu作为镜像，当然，国外源那 超慢 的下载速度是不可忍受的，因此，我基于ubuntu官方镜像制作了一自己的ubuntu镜像，镜像非常简单，仅是更换了国内官方源并安装了supervisor而已，Dockerfile如下： 1 # image: haruka/ubuntu 2 3 FROM ubuntu 4 MAINTAINER haruka "paruka.me@gmail.com" 5 6 ADD sources.list /etc/apt/ 7 8 RUN apt-get update 9 RUN apt-get upgrade -y 10 11 # supervisor 12 RUN apt-get install -y supervisor 13 RUN mkdir -p /var/log/supervisor 除此之外，我们还需要在运行系统时，通过GDB附加进程调试，因此，容器需要运行sshd（为方便使用，密码设为111）： 1 # image: haruka/sshd 2 3 FROM haruka/ubuntu 4 MAINTAINER haruka "paruka.me@gmail.com" 5 6 RUN apt-get update 7 RUN apt-get upgrade -y 8 9 # SSHD 10 RUN apt-get install -y openssh-server openssh-client 11 RUN mkdir /var/run/sshd 12 RUN echo 'root:111' | chpasswd 13 RUN sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config 14 RUN sed 's@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd 15 ENV NOTVISIBLE "in users profile" 16 RUN echo "export VISIBLE=now" &gt;&gt; /etc/profile 17 18 19 EXPOSE 22 20 CMD ["/usr/sbin/sshd", "-D"] 接下来便是安装QEMU了： 1 # image: haruka/qemu 2 3 FROM haruka/sshd 4 MAINTAINER haruka "paruka.me@gmail.com" 5 6 RUN apt-get update 7 RUN apt-get upgrade -y 8 RUN apt-get install -y build-essential libtool libglib2.0-dev libpixman-1-dev zlib1g-dev git libfdt-dev gcc-multilib gdb 9 10 RUN mkdir -p /root/qemu 11 12 #source为qemu源码 13 ADD source /root/qemu 14 15 WORKDIR /root/qemu 16 RUN ./configure 17 RUN make &amp;&amp; make install 依次进入目录，创建镜像： 1 sudo docker build -t haruka/ubuntu --rm=true . 2 sudo docker build -t haruka/sshd --rm=true . 3 sudo docker build -t haruka/qemu --rm=true . 漫长的等待过后，镜像便创建完成了，通过以下命令进行实验： 1 # /dir/to/lab/source&#20026;lab&#25152;&#22788;&#20301;&#32622; 2 # git clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab 3 sudo docker run -d -p 10000:22 -v /dir/to/lab/source:/root/lab haruka/qemu 4 ssh root@localhost -p 10000 容器启动脚本 容器虽已搭建完成，但每次开始实验都需要手动开启容器、连接ssh，显得非常繁琐，因此我编写了一个脚本： jos ，简化这一流程： 1 #!/bin/bash 2 #set -eu 3 4 LAB_DIR=/home/haruka/Documents/OS/lab 5 LAB_MOUNT_TO=/root/lab 6 USING_IMAGE="haruka/qemu" 7 CONTAINER_NAME="jos" 8 DEFAULT_PORT=20000 9 10 11 function process_options 12 { 13 i=1 14 while [ $i -le $# ]; do 15 case "${!i}" in 16 -s|--startup) startup=1;; 17 -p|--poweroff) poweroff=1;; 18 -P|--port) 19 (( i++ )) 20 port=${!i} 21 ;; 22 -l|--list) desp=1;; 23 esac 24 (( i++ )) 25 done 26 } 27 28 function do_startup 29 { 30 docker run -d -p ${1}:22 -v ${LAB_DIR}:${LAB_MOUNT_TO} --name ${CONTAINER_NAME} ${USING_IMAGE} 31 } 32 33 function do_poweroff 34 { 35 if [ ${1} ]; then 36 docker kill ${1} 37 docker rm ${1} 38 fi 39 } 40 41 function rm_container 42 { 43 ids=$(docker ps -q -f "status=${1}" -f "name=${CONTAINER_NAME}") 44 if [ ${ids} ]; then 45 docker rm ${ids} 46 fi 47 } 48 49 function do_cleanup 50 { 51 rm_container "exited" 52 rm_container "created" 53 } 54 55 function do_connect 56 { 57 ssh_port=$(docker port ${CONTAINER_NAME} | grep "22/tcp" | awk -F: '{print $2}') 58 ssh root@localhost -p ${ssh_port} 59 } 60 61 startup= 62 poweroff= 63 port= 64 desp= 65 66 if [ ${EUID} != 0 ]; then 67 echo "Please run as root" 68 exit 69 fi 70 71 process_options $@ 72 73 container_id=$(docker ps -q -f "name=${CONTAINER_NAME}") 74 75 76 if [ ${poweroff} ]; then 77 if [ ${container_id} ]; then 78 do_poweroff ${container_id} 79 fi 80 81 do_cleanup 82 exit 83 fi 84 85 if [ ${desp} ]; then 86 if [ ${container_id} ]; then 87 echo "container is running!" 88 echo "container id: ${container_id}" 89 docker port ${CONTAINER_NAME} 90 exit 91 fi 92 93 if [ $(docker ps -q -f "status=exited" -f "name=${CONTAINER_NAME}") ]; then 94 echo "container exited, run: \"sudo jos -p\" to cleanup" 95 exit 96 fi 97 98 if [ $(docker ps -q -f "status=created" -f "name=${CONTAINER_NAME}") ]; then 99 echo "container created, run: \"sudo jos -p\" to cleanup" 100 exit 101 fi 102 103 echo "no container is running" 104 exit 105 fi 106 107 if [ ! ${container_id} ]; then 108 do_cleanup 109 do_startup ${port:-$DEFAULT_PORT} 110 fi 111 112 if [ ${startup} ]; then 113 exit 114 fi 115 116 do_connect 执行脚本时，默认行为为： 若容器未运行，则运行容器 使用ssh连接容器 因此，将脚本目录加入环境变量，开始实验就变得非常简单了： 1 #&#25171;&#24320;&#19968;&#32456;&#31471;&#65292;&#24320;&#22987;&#23454;&#39564; 2 sudo jos 3 4 #&#20197;&#35843;&#35797;&#27169;&#24335;&#36816;&#34892;jos 5 make qemu-gdb 6 7 #&#24320;&#21551;&#21478;&#19968;&#32456;&#31471;&#65292;&#36830;&#20837;&#23481;&#22120; 8 sudo jos 9 10 #gdb&#38468;&#21152;jos&#65292;&#24320;&#22987;&#21333;&#27493;&#35843;&#35797; 11 make gdb 12 13 #&#20851;&#38381;&#23481;&#22120; 14 sudo jos -p Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Study Notes</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>mit 6.828</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款24：区别通用引用与右值引用]]></title>
    <url>%2Ftranslation%2Feffective_modern_cpp%2Fitem24.html</url>
    <content type="text"><![CDATA[都说真理让人如获自由，但在正确的情形下，一个恰当的谎言却能产生同样的效果。此条款便是一个这样的谎言。不过，我们是在与软件打交道，因此，应避免使用"谎言"这样的敏感词汇，故用"抽象"一词取而代之。 你使用 T&amp;&amp; 的方式来声明一右值引用。因此，假定代码中看到的"T&amp;&amp;"为右值引用，似乎合乎情理。哎，可惜它并非如此简单。 1 void f(Widget&amp;&amp; param); // rvalue reference 2 3 Widget&amp;&amp; val1 = Widget(); // rvalue reference 4 5 auto&amp;&amp; var2 = val1; // not rvalue reference 6 7 template &lt;typename T&gt; 8 void f(std::vector&lt;T&gt;&amp;&amp; param); // rvalue reference 9 10 template &lt;typename T&gt; 11 void f(T&amp;&amp; param); // not rvalue reference 事实上，"T&amp;&amp;"有两个不同的含义。其一当然就是右值引用。这种引用类型表现的与你期望的完全一致：它们只能绑定至右值，主要的存在目的1为标识那些能移动的对象。 "T&amp;&amp;"的另一个含义既不是右值引用，也不是左值引用，这种引用在代码中看起来像是右值引用（"T&amp;&amp;"），却可以表现出左值引用的行为（"T&amp;"）。这种双重性允许它们既能绑定右值（像右值引用）也能绑定左值（像左值引用），而且还能绑定至 const 、 non-const 、 volatile 、 non-volatile 属性的对象，即使它们同时拥有 const 和 volatile 属性也毫不例外（可以绑定），实际上，它们可以绑定至任何对象。这种空前复杂的引用应当被赋予一专属名字。我称之为 通用引用（universal references）2 。 通用引用于两种情境中出现。最常见的情境为模板函数的参数。正如之前所列例子中引出的如下代码： 1 template &lt;typename T&gt; 2 void f(T&amp;&amp; param); // param is a universal reference 第二种情境便是 auto 声明，以下例子同样引用自之前所列示例： 1 auto&amp;&amp; var2 = var1; // var2 is a universal reference 这些情境的共通点便是 类型推导 。对于模板函数f， param 的类型会被推导，var2的声明同样如此，他的类型一样会被推导。与如下例子对比（同样引自之前所列示例），它们缺乏类型推导。因此，当你发现"T&amp;&amp;"没有类型推导，它便是右值引用： 1 void f(Widget&amp;&amp; param); // no type deduction; 2 // param is an rvalue reference 3 4 Widget&amp;&amp; var1 = Widget(); // no type deduction; 5 // var1 is an rvalue reference 通用引用也是引用，因此，它们必须被初始化。通用引用的初始值决定了它应表现为右值引用或是左值引用。如果初始值为右值，通用引用相当与一右值引用。如果初始值为左值，它便相当于一左值引用。对于模板参数中的通用引用，它的初始化由调用端提供： 1 template &lt;typename T&gt; 2 void f(T&amp;&amp; param); // param is a universal reference 3 4 Widget w; 5 f(w); // lvalue passed to f; param's type is 6 // Widget&amp; (i.e., an lvalue reference) 7 8 f(std::move(w)); // rvalue passed to f; param's type is 9 // Widget&amp;&amp; (i.e., an rvalue reference) 对于（成为）通用引用，类型推导是必须的，却并不足够。其引用声明形式必须正确，声明样式非常固定，必须为精确的"T&amp;&amp;"样式。参看引自之前例子的代码： 1 template &lt;typename T&gt; 2 void f(std::vector&lt;T&gt;&amp;&amp; param); // param is an rvalue reference 当f被调用，类型 T 会被推导（除非调用者直接指定，这种边缘情况我们并不关心）。但 param 的类型声明并不是"T&amp;&amp;"，而是"std::vector&lt;T&gt;&amp;&amp;"，它并不满足通用引用的声明规则。因此， param 为右值引用，如果你试图向 f 传入一左值，编译器将很乐于向你证明这点： 1 std::vector&lt;int&gt; v; 2 f(v); // error! can't bind lvalue to 3 // rvalue reference 哪怕是一小小的 const 修饰符，也足以让它失去成为通用引用的资格： 1 template &lt;typename T&gt; 2 void f(const T&amp;&amp; param); // param is an rvalue reference 于模板函数中看到 T&amp;&amp; 类型的参数时，你可能会认为它是一个通用引用。但这并不总是正确，因为模板并不能保证类型推导的发生。考虑 std::vector 的 push_back 成员函数： 1 template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; // from C++ 2 class vector{ // Standards 3 void push_back(T&amp;&amp; x); 4 ... 5 } push_back 的参数完全符合通用引用的声明样式，但却没有发生类型推导。这是因为 push_back 是作为 vector 实例化后的一部分存在的，而这个实例化已经完全确定了 push_back 的声明，也就是说： 1 std::vector&lt;Widget&gt; v; 会使 std::vector 实例化为如下样式： 1 class Vector&lt;Widget, allocator&lt;Widget&gt;&gt; 2 { 3 public: 4 void push_back(Widget&amp;&amp; x); // rvalue reference 5 } 现在你可以很清楚的看到， push_back 并没有触发类型推导。 std::vector 的 push_back 方法（有两个──函数重载）总是声明了一个 T 类型的右值引用作为参数。相反，与其功能类似的另一成员函数 emplace_back 则触发了类型推导： 1 template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; // still from 2 class vector { // C++ 3 public: // Standards 4 template &lt;class... Args&gt; 5 void emplace_back(Args&amp;&amp;... args); 6 ... 7 } 这里的类型参数 Args 与 vector 的类型参数独立，因此每次 emplace_back 调用的时候都会发生类型推导。（好吧，其实 Args 是一个参数包，不是一具体的参数类型，但为了更好的讨论这一话题，我们可以视其为一类型参数）。 事实上， emplace_back 的类型参数为 Args ，是一个通用引用，这一事实巩固了我之前所述的观点：通用引用的声明样式必须为"T&amp;&amp;"，但并没有对名字 T 的使用有要求。例如如下模板函数便接收一通用引用类型的参数，它的声明样式（"type&amp;&amp;"）正确，且参数类型需要推导（再次强调：需排除调用者显示指定类型的极端情况）： 1 template &lt;typename MyTemplateType&gt; // param is a 2 void someFunc(MyTemplateType&amp;&amp; param); // universal reference 我之前讲过， auto 类型的变量也可以是通用引用。更精确的说，声明为 auto&amp;&amp; 类型的变量就是通用引用，因为它满足通用引用样式（"T&amp;&amp;"）且触发了类型推导。 auto 通用引用并不像模板参数中的通用引用那么常见，它们在 C++11 中偶有出现，于 C++14 中变得更加频繁，因为 C++14 允许在 lambda 表达式中使用 auto&amp;&amp; 声明参数。例如，在 C++14 中，如果你想编写一 lambda 表达式以记录任一函数的调用耗时，你可以这样编写： 1 auto timeFuncInvocation = 2 [](auto&amp;&amp; func, auto&amp;&amp;... params) // C++14 3 { 4 start timer; 5 std::forward&lt;decltype(func)&gt;(func)( // invoke func 6 std::forward&lt;decltype(params)&gt;(params)... // on params 7 ); 8 stop timer and record elapsed time; 9 }; 如果你对"std::forward&lt;decltype(blah blah blah)&gt;"的反应是"誒？！"，那就说明你尚未阅读条款33，不过不用担心。这里关注的重点是 lambda 中的 auto&amp;&amp; 声明的参数。 func 是一个可绑定至任一可调用对象的通用引用，不论左值或右值。 args 是零个或多个通用引用（一个通用引用参数包），它可以绑定任意个数任何类型的对象。结果就是，拜 auto 通用引用所赐， timeFuncInvocation 可以计算几乎所有函数的执行耗时。（关于"任意"和"几乎所有"的区别，请参看条款30。） 记住，此条款 ──通用引用的基础── 是个谎言&#x2026;呃，应该叫"抽象"。隐含其中的真相是引用折叠，既条款28的主题。但这一真相并没有减少此抽象的用处。区分右值引用与通用引用能帮助你更精确的阅读代码（"这里的 T&amp;&amp; 只能绑定到右值？还是都能绑定？"），也能让你与同事的交流更加顺畅（"在这里我使用的是通用引用，不是右值引用&#x2026;&#x2026;"）。也将使你更易理解条款25与条款26，它们都依赖于这一区分。所以，拥抱它吧。并陶醉其中。正如牛顿运动定律（实际上是不正确的），它通常比爱因斯坦的广义相对论（"真相"）更为有用、简单，因此，通用引用的概念通常比它的细节──引用折叠更为可取。 记住 如果一个模板函数的参数是 T&amp;&amp; ，且 T 需要被推导，或者一个对象被声明为 auto&amp;&amp; ，那么该参数或此对象为通用引用。 如果类型声明并未满足严格的 type&amp;&amp; 样式，或者没有发生类型推导， type&amp;&amp; 表示一个右值引用。 通用引用在使用右值初始化时相当于一右值引用。在使用左值初始化时相当于一左值引用。 Footnotes: 1 法语：raison d'être 2 条款25会告诉你：通用引用几乎都要配合 std::forward 使用，因此此书即将出版时，许多C++标准委员会的成员开始称 universal references 为 forwarding references 。 Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
        <tag>Press Ban</tag>
        <tag>禁止转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Copy elision]]></title>
    <url>%2Ftranslation%2Fcppreference%2Fcopy_elision.html</url>
    <content type="text"><![CDATA[翻译至cppreference。 优化了拷贝 及移动(since C++11) 构造函数，提供值传递的零拷贝语义。 解释 在以下情况，编译器必须省略拷贝及移动构造函数的调用，即便该对象的拷贝/移动构造函数和析构函数有明显的副作用。它们（拷贝／移动构造函数）不必存在或可访问，因为语言规则在概念上就确保不会发送拷贝／移动。 初始化时，若初始化语句是一个prvalue且它的cv-unqualified类型与目标的类型相同，该初始化语句将直接用于初始化目标对象。 1 T x = T(T(T())); // &#21482;&#20250;&#35843;&#29992;&#19968;&#27425;T&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968; 在函数调用中，函数返回语句的操作数是一个prvalue，且与该函数的返回值类型相同。 1 T f() { return T{}; } 2 T x = f(); // &#21482;&#20250;&#35843;&#29992;&#19968;&#27425;T&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968; 3 T* p = new T(f()); // &#21482;&#20250;&#35843;&#29992;&#19968;&#27425;T&#30340;&#40664;&#35748;&#26500;&#36896;&#20989;&#25968; 在以下情况，允许编译器省略拷贝及复制构造函数的调用，即便该对象的拷贝/复制构造函数和析构函数有明显的副作用。 函数以值方式返回一个对象，且返回语句的表达式是一个拥有自动存储期1的non-volatile对象，它不能是该函数的参数或catch语句的参数，其类型（忽略最高层的cv-qualification）必须与函数返回值类型一致，此时拷贝/复制函数会被忽略（since C++11）。该临时对象将直接于函数调用处构造（拷贝或移动）。这种类型的禁止拷贝行为，我们称其为NRVO，"named return value optimization"。 一个未绑定至任何引用的无名临时变量，会被移动（Since C++11）或拷贝至同类型的其他对象(忽略最高层的cv-qualification)，此时复制/移动（Since C++11）会被忽略。此临时变量会在函数调用处构造（拷贝或移动）。当该无名临时对象是函数的返回值时，这种类型的拷贝禁止行为被称为RVO，"return value optimization"。(until C++17) 以上优化所有编译器必须实现。(since C++17) （since C++11）在一个异常抛出语句中，如果操作数是一个拥有自动存储期的non-volatile对象，它不能是函数的参数或catch语句的参数，且生命期没有跨越最里层的try语句块（如果有），此时，拷贝/移动会被忽略。该临时变量将直接于异常对象捕获处构造（拷贝或移动）。 （since C++11）处理异常时，如果catch语句的参数类型与抛出的异常对象的类型一致（忽略最高层的cv-qualification），拷贝会被忽略，catch子句将直接访问该异常对象，正如被引用一般。在可能改变程序行为的情况下（非忽略拷贝构造函数及析构函数的调用），该优化不会生效（例如：catch子句的参数被修改，并将该异常对象通过*throw*语句重新抛出）。 当 copy elision 发生时，拷贝/ 移动（since C++11） 操作的省略，是通过将目标及源对象视为同一对象的两个不同引用实现的，它的析构并不会被省略，只会推迟至两个对象均已销毁时发生 （除非目标对象是通过其右值引用版本的构造函数创建的，这种情况下，析构将发生在目标对象销毁时）(since C++17) 。 copy elision 可以嵌套触发以消除多重拷贝。 在常量表达式及常量初始化语句中，所有满足 copy elision 的地方都会触发(graranteed)（by post-C++14 defect report CWG 2022）: 1 // since c++14 2 3 struct A { 4 void *p; 5 constexpr A(): p(this) {} 6 }; 7 8 constexpr A g() { 9 A a; 10 return a; 11 } 12 13 constexpr A a; // a.p points to a 14 constexpr A b = g(); // b.p points to b (NRVO guaranteed) 15 16 void g() { 17 A c = g(); // c.p may point to c or to an ephemeral temporary 18 } 注意 Copy elision 是 唯一一种标准允许的优化策略(until C++14) ， C++14还引入了另一种优化：allocation elision and extension ，它可能触发显著的副作用。因为一些编译器并不会在所有满足条件的地方触发copy elision(例如：调试模式)，那些依赖于拷贝／移动构造函数及析构函数副作用的程序将不可移植。 在 return语句 或 throw语句 中，如果编译器无法对满足条件的地方执行copy elision，且源目标不是函数参数，编译器将试图使用移动构造函数，即便该对象是左值；详情请看return statement。 例子 1 #include &lt;iostream&gt; 2 #include &lt;vector&gt; 3 4 struct Noisy 5 { 6 Noisy() { std::cout &lt;&lt; "constructed\n"; } 7 Noisy(const Noisy&amp;) { std::cout &lt;&lt; "copy-constructed\n"; } 8 Noisy(Noisy&amp;&amp;) { std::cout &lt;&lt; "move-constructed\n"; } 9 ~Noisy() { std::cout &lt;&lt; "destructed\n"; } 10 }; 11 12 std::vector&lt;Noisy&gt; f() 13 { 14 std::vector&lt;Noisy&gt; v = std::vector&lt;Noisy&gt;(3); // copy elision when initializing v 15 // from a temporary (until C++17) 16 // from a prvalue (since C++17) 17 return v; // NRVO from v to the result object (not guaranteed in C++17) 18 } // if optimization is disabled, the move constructor is called 19 20 void g(std::vector&lt;Noisy&gt; arg) 21 { 22 std::cout &lt;&lt; "arg.size() = " &lt;&lt; arg.size() &lt;&lt; '\n'; 23 } 24 25 int main() 26 { 27 std::vector&lt;Noisy&gt; v = f(); // copy elision in initialization of v 28 // from the temporary returned by f() (until C++17) 29 // from the prvalue f() (since C++17) 30 g(f()); // copy elision in initialization of the parameter of g() 31 // from the temporary returned by f() (until C++17) 32 // from the prvalue f() (since C++17) 33 } 可能的输出： 1 constructed 2 constructed 3 constructed 4 constructed 5 constructed 6 constructed 7 arg.size() = 3 8 destructed 9 destructed 10 destructed 11 destructed 12 destructed 13 destructed 缺陷 以下缺陷报表(defect reports)追溯到之前的C++标准。 DR Applied to Behavior as published Correct behavior CWG 2022 C++14 copy elision was optional in constant expressions copy elision mandatory 参阅 copy initialization copy constructor move constructor Footnotes: 1 automatic storage duration Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>cppreference</category>
      </categories>
      <tags>
        <tag>cppreference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款23：理解std::move和std::forward]]></title>
    <url>%2Ftranslation%2Feffective_modern_cpp%2Fitem23.html</url>
    <content type="text"><![CDATA[第五章 右值引用、移动语义及完美转发 当你初次学习它们时，移动语义和完美转发看起来非常直白： 移动语义 让编译器将代价高昂的拷贝操作替换为相对低廉的移动操作。正如其名，拷贝构造函数及拷贝赋值函数给予你控制对象复制的能力，与此类似，移动构造函数和移动赋值函数则给予你控制移动语义的能力。移动语义还允许你创建move-only类型的对象，例如： std::unique_ptr 、 std::future 和 std::thread 。 完美转发 使我们可以将模板函数的实参（任意修饰符的实参）转发给另一函数。 右值引用是这两个迥异特性的粘合剂。它们是构成移动语义及完美转发的基石。 随着对这些特性的深入理解，你将更加意识到，你对它们一开始的印象，只不过是冰山一角。它们（移动语义、完美转发和右值引用）比呈现出来的（样子）更加微妙。比如： std::move 并不移动任何东西，完美转发也并不完美。移动操作并非都比拷贝廉价、并非一直如你期盼的廉价、也并非在每个具有有效移动语义的地方被调用。 type&amp;&amp; 也并非一直代表右值引用。 无论你对那些特性进行多么深入的研究，它们看上去似乎总是隐藏着更多的秘密。幸运的是，它们并非深不可测。本章将助你打开这扇神秘的大门，跨过大门，你将对C++11中的这部分内容有更深入的理解。你将掌握 std::move 和 std::forward 的使用语境，并对那歧义性十足的"type&amp;&amp;"有更本质的理解，当然，你也将领悟到为何移动操作(move operation)会表现出令人惊奇的多样性行为。之后，我们又回到了原点，因为移动语义、完美转发和右值引用看起来似乎再次变得非常直白。但现在，它们已不再神秘。 在本章的所有条款中，你需要记住，实参永远是左值，即便形参类型为右值引用！这点尤为重要。例如，给定如下函数： 1 void f(Widget&amp;&amp; w); w是一个左值，尽管它的类型为Widget的右值引用。（如果你感到惊讶，请复习本书第二页中左值与右值相关的内容。） 条款23：理解std::move和std::forward. 了解 std::move 和 std::forward 不会做些什么非常有用。 std::move 不会移动任何东西。 std::forward 也不会转发任何东西。它们不会在运行时做任何事情，不会生成哪怕是一比特的可执行代码。 std::move 和 std::forward 仅仅是两个转换函数（其实是函数模板）。 std::move 无条件的将它的实参转换为右值，而 std::forward 仅在满足条件的情况下，才执行这一转换（转换为右值）。这一解释虽触发了一连串的疑问，但这却是事实。 为了更好的诠释这一事实，我们复刻了C++11中 std::move 的实现，它只是一个例子，虽未完全符合标准（C++标准），但已非常接近： 1 template&lt;typename T&gt; 2 typename remove_reference&lt;T&gt;::type&amp;&amp; // in namespace std 3 move(T&amp;&amp; param) 4 { 5 using ReturnType = // alias declaration; 6 typename remove_reference&lt;T&gt;::type&amp;&amp;; // see Item 9 7 8 return static_cast&lt;ReturnType&gt;(param); 9 } 我为你高亮标识了代码中的两个部分：函数名及转换语句。标识函数名是因为返回值类型过于复杂，我不希望你迷失其中失去耐心，而那条转换语句，则包含了此函数的精髓。正如你所见， std::move 接收一对象的引用（通用引用: universal reference，详情参阅条款24），并返回该对象的引用。 返回值中的"&amp;&amp;"暗示我们， std::move 返回一右值引用，但正如条款28所述，如果 T 恰巧是一左值引用， T&amp;&amp; 将同为左值引用。为避免这一情况，型别类型判定技法（type trait，参照条款9）中的 std::remove_reference 便派上了用场，它作用与 T ，以确保"&amp;&amp;"被应用与一个型别（a type）而不是引用。这对确保 std::move 返回右值引用非常重要，因为函数返回的右值引用是右值。因此 std::move 将传递给它的参数转换为右值，这便是它所做的一切。 当然，用C++14实现 std::move 将更加优雅。这归功于函数的返回值类型推导（参照条款3）及标准库中的模板别名 std::remove_reference_t （参照条款9），实现如下： 1 template&lt;typename T&gt; // C++14; still in 2 decltype(auto) move(T&amp;&amp; param) // namespace std 3 { 4 using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;; 5 return static_cast&lt;ReturnType&gt;(param); 6 } 看起来更加简单了，是不是？ 正因如上所诉（ std::move 只是将传递给它的参数转换为右值），许多人建议将它命名为 rvalue_cast 之类的东西。尽管如此，它仍被命名为 std::move ，所以，你必须要记住： std::move 仅转换不移动。 当然，右值可以被移动，所以，对一个对象调用 std::move 将告诉编译器，它可以被移动。这便是这一命名的用意：一眼便可看出该对象可以被移动。 事实上，只有右值能被移动。假设你正编写一个备注类，它的构造函数接收一个用以描述备注内容的 std::string 对象，并将其拷贝至该类的数据成员中。遵循条款24的建议，我们将该参数以值传递： 1 class Annotation { 2 public: 3 explicit Annotation(std::string text); // param to be copied, 4 ... // so per Item 41, 5 }; // pass by value 可是， Annotation 的构造函数只需要读取 text 的内容，不需要对它做任何修改。因此，基于 尽可能的使用const 这一古老传统，你将你的申明稍作改进： 1 class Annotation { 2 public: 3 explicit Annotation(const std::string text); 4 ... 5 }; 最后，为减少 text 至数据成员的一次拷贝开销，你遵循条款41的建议，对 text 使用 std::move ，以便产生一个右值： 1 class Annotation { 2 public: 3 explicit Annotation(const std::string text) 4 : value(std::move(text)) // "move" text into value; this code 5 {...} // doesn't do what it seems to! 6 7 ... 8 9 private: 10 std::string value; 11 }; 编译、链接、运行，它运行的如你所愿，却与你追求的完美相差甚远，只因 text 未被移动，而是拷贝。 text 虽被 std::move 转换为了右值，但它却被申明为 const std::string ，因此，在被转换前， text 是一 const std::string 类型的左值，在转换后，常属性得以保留，变成一 const std::string 类型的右值。 思考一下编译器选择调用 std::string 构造函数的情形，它有两种可能性： 1 class string { // std::string is actually a 2 public: // typedef of std::basic_string&lt;char&gt; 3 ... 4 string(const string&amp; rhs); // copy ctor 5 string(string&amp;&amp; rhs); // move ctor 6 }; 在 Annotation 类的构造函数初始化列表中， std::move(text) 的结果是一个 const std::string 类型的右值。它不能被传递至 std::string 的移动构造函数，因为它（移动构造函数）接收一非常量 std::string 的右值引用作为参数。但它却可以被传递给拷贝构造函数，因为常左值引用可以绑定至常右值。因此， value 的初始化便调用了 std::string 的拷贝构造函数，尽管 text 已经被转换为右值！这一行为对维持常量正确性（常量属性的正确性：const-correctness）非常重要，毕竟将对象的值移出该对象便意味着修改了该对象1，因此，语法层面上应禁止将const对象传递至那些会对对象进行修改的函数（正如拷贝构造函数）。 从这个例子中，我们得出两条结论。第一，不要将有可能进行移动操作的对象申明为 const ，因为对常量对象的移动操作，会自动的转换为拷贝操作。第二， std::move 并不会移动任何东西，也不能保证其转换出的对象能被移动。唯一能确定的是 std::move 处理后的对象是一个右值。 std::forward 与 std::move 类似，只不过 std::move 会无条件的将其参数转换为右值，而 std::forward 只会在特定的情形下才进行转换。因此， std::forward 是有条件的转换。要理解它的转换条件，就需要我们回忆一下 std::forward 的使用情景。最常用的使用情景便是在一接收通用引用为参数的模板函数中，将其参数传递给另一函数： 1 void process(const Widget&amp; lvalArg); // process lvalues 2 void process(Widget&amp;&amp; rvalArg); // process rvalues 3 4 template&lt;typename T&gt; // template that passes 5 void logAndProcess(T&amp;&amp; param) // param to process 6 { 7 auto now = // get current time 8 std::chrono::system_clock::now(); 9 10 makeLogEntry("Calling 'process'", now); 11 process(std::forward&lt;T&gt;(param)); 12 } 考虑分别用左值和右值调用 logAndProcess 方法的情形： 1 Widget w; 2 3 logAndProcess(w); // call with lvalue 4 logAndProcess(std::move(w)); // call with rvalue 在函数 logAndProcess 中，参数 param 被传递给 process 函数， process 函数有针对左值及右值参数的重载。我们自然希望，在使用左值调用 process 函数时，该左值会被转发给 process ，而在使用右值调用 logAndProcess 函数时，则会调用相应的右值重载版本。 可是，所有的参数（正如所有的函数参数一样），都是左值。因此，在函数 logAndProcess 中对 process 的调用，都会触发左值重载版本的 process 函数。为阻止这种情况发生，我们需要一种机制，它能在适当的时候 ──当传递给 logAndProcsss 的参数是右值的时候── 将参数转换为右值。这便是 std::forward 所做的事情。因此， std::forward 被称为条件转换：它仅在其参数由右值初始化时，才将其转换为右值。 你也许会想知道， std::forward 是如何知道其参数是由右值初始化而来的。例如，在如上例子中， std::forward 是如何知道初始化其参数的是左值还是右值？要点在于 logAndProcess 的模板参数T，参数的左、右值信息便隐藏其中，借由 std::forward 将其还原。详细情况我将与条款28中为你讲述。 std::move 和 std::forward 都被归结为类型转换函数，它们的唯一区别是 std::move 总是进行转换，而 std::forward 则只会在需要的时候进行转换，你也许会问，我们是否可以摒弃 std::move ，只使用 std::forward ？从技术层面来说，你可以那么做， std::move 不是必须的。当然，你可以认为它们两都不是必须的，因为你可以在任何需要转换的地方手动编写转换代码，但我还是希望大家尽量使用它们，毕竟随处可见的相似代码（手动编写的类型转换代码），并不符合软件开发的哲学。 std::move 的吸引力在于方便、减少可能的错误以及语义清晰。如果我们需要统计某移动构造函数的调用次数，我们只需要定义一静态计数器，将其于移动构造函数中自增，假使该类仅有一个 std::string 类型的非静态成员变量，那么，移动构造函数的实现便非常简单（使用 std::move ）： 1 class Widget { 2 public: 3 Widget(Widget&amp;&amp; rhs) 4 : s(std::move(rhs.s)) 5 { ++moveCtorCalls; } 6 7 ... 8 private: 9 static std::size_t moveCtorCalls; 10 std::string s; 11 }; 当然，也可以使用 std::forward 实现该函数： 1 class Widget { 2 public: 3 Widget(Widget&amp;&amp; rhs) // unconventional, 4 : s(std::forward&lt;std::string&gt;(rhs.s)) // undesirable 5 { ++moveCtorCalls; } // implementation 6 7 ... 8 }; 注意，在使用 std::move 时，你只需向它传递一个参数（rhs.s）即可，而 std::forward 还需要指定一个模板参数（ std::string ），你不需要为它（模板参数）指定引用类型，因为这（它是一个右值）已经是约定俗成的东西了（参阅条款28）。因此使用 std::move 比 std::forward 更方便，还能避免错误的类型参数导致的行为异常（例如：传入 std::string&amp; 将导致成员变量 s 被拷贝构造，而不是移动构造）。 更重要的是， std::move 的使用给我们传递了无条件右值转换的语义，而 std::forward 则表明仅会对绑定至右值的参数进行转换，这是两种完全不同的行为，前者是典型的移动，后者只是将对象── 转发 ──给另一函数，并保留它的左、右值属性，因此，设计两个完全不同的函数（及函数名）区分它们，是一个很好的决议。 记住： std::move 无条件的将其参数转换为右值，它不会进行任何移动。 std::forward 只会在其参数为右值时，才会进行转换。 std::move 与 std::forward 均无运行时开销。 Footnotes: 1 Moving a value out of an object generally modifies the object.意为对该对象调用 std::move 后，该对象变成了右值，其实便是修改了该对象，与该对象的const属性相矛盾。 Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
        <tag>Press Ban</tag>
        <tag>禁止转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Value categories]]></title>
    <url>%2Ftranslation%2Fcppreference%2Fvalue-categories.html</url>
    <content type="text"><![CDATA[翻译至cppreference、cppreference，并对其进行了整合。(虽然我并不明白这两个网站的区别&#x2026;) 每一个C++表达式（有操作数的运算符、字面值、变量名等）都被赋予两种独立的属性：型别和值类型（value categories）。每一个表达式都有一些非引用的类型，且归属与以下三种值类型中的一种：prvalue、xvalue、lvalue。它们的定义如下： glvalue1是一个其值（运算结果）能标识一个对象、位域或函数的表达式。 prvalue2表达式既 是一个运算符（使用某些操作数运算后）的值（这样的prvalue没有返回对象），也能 （用其值）初始化一个对象或位域（这样的prvalue我们称其拥有返回对象）。所有类、数组类型的prvalue都有一个返回值，哪怕它会被抛弃。 xvalue3是一个（其对象或位域）可被复用的glvalue。 lvalue是那些不属于xvalue的glvalue。 rvalue是一个prvalue或xvalue。 注意: 这一分类方式与之前的C++标准相比有巨大的变化，详情请看历史。 Primary categories 主类型对应表达式的两个属性： 有身份 : 可以确定各表达式标识的对象是否为同一对象，例如：比较它们的地址或者调用它们的标识函数。 可被移动 : 移动构造函数、移动赋值函数或其它实现了移动语意的函数是否可绑定至该表达式。 因此： 有身份且不能被移动的表达式为 lvalue 表达式； 有身份且能被移动的表达式为 xvalue 表达式； 无身份且能被移动的表达式为 prvalue 表达式； 无身份且不能被移动的表达式并不存在。 lvalue lvalue ("left value")表达式有身份且不能被移动。"左值"这个名字具有历史性的意义，它完美的标识了它在CPL编程语言中的作用：赋值运算符的左操作数。 以下表达式均为lvalue（左值）表达式: 作用域内的、任意类型的变量名或函数名，例如： std::cin 、 std::endl 。即便变量的类型是右值引用，由它的名字组成的表达式也是一个左值表达式。 一个返回值为左值引用的函数调用或返回值为左值引用的运算符重载表达式，例如： std::getline(std::cin, str) 、 std::cout &lt;&lt; 1 、 str1 = str2 、 ++it 。 a=b 、 a+=b 、 a%=b ，及其它内置的赋值、复合赋值表达式。 ++a 和 --a ： 内置的前置自增、前置自减表达式。 *p ：内置的指针取值表达式。 a[n] 和 p[n] ：内置的取下标表达式， a不能为右值数组。(since c++11) 。 a.m ：对象成员表达式，除非m是枚举或非静态成员函数，又或者a是右值且m为非引用类型的非静态成员。 p-&gt;m ：内置的指针所指对象的成员表达式，m不能为枚举或非静态成员函数。 a.*mp: 对象成员指针表达式，a必须为左值且mp必须指向数据成员。 p-&gt;*mp ：内置的指向成员指针的指针表达式，mp必须指向数据成员。 a, b: 内置的逗号表达式，b必须为左值。 a ? b : c ：某些三元条件表达式。 字符串字面值，例如： "Hello World!" 。 转换为左值引用的转换表达式，例如: static_cast&lt;int&amp;&gt;(x) 。 对返回值为右值引用的方法的调用或返回值为右值引用的运算符重载表达式(since c++11)。 转换为函数右值引用的转换表达式，例如： static_cast&lt;void (&amp;&amp;)(int)&gt;(x) (since c++11)。 属性: 拥有glvalue的所有属性(稍后介绍)。 可以获取左值的地址： &amp;++i 4和 &amp;std::endl 都是合法的表达式。 可修改的左值可以做为内置赋值、复合赋值运算符的左操作数。 左值可以用来初始化左值引用；此时该表达式标识的对象将被赋予一个全新的别名。 prvalue prvalue("pure rvalue") 表达式是那些 没有身份 且 可以被移动 的表达式。 以下表达式均为prvalue表达式： 字面值（除字符串字面值），例如： 42 、 true 或 nullptr ； 返回值为非引用类型的函数的调用或返回值为非引用的运算符重载表达式，例如： str.substr(1, 2) 、 str1+str2 、 it++ 。 a++ 及 a-- ，内置的后置自增、自减运算符表达式； a+b 、 a%b 、 a&amp;b 、 a&lt;&lt;b 及其它所有的内置算数表达式； a&amp;&amp;b 、 a||b 、 ~a ，内置的逻辑表达式； a&lt;b 、a==b、a&gt;=b 及其它所有内置的比较表达式； &amp;a ，内置的取地址表达式； a.m ，对象成员表达式，其中m必须为枚举或非静态成员函数5，或 a为rvalue且m为非引用类型的非静态数据成员（until c++11） ； p-&gt;m ，内置的指针所指对象的成员表达式，其中m必须为枚举或非静态成员函数6； a.*mp ，对象的成员指针表达式，其中mp是一个指向成员函数的指针7，或 a是一个右值且mp为一指向数据成员的指针（until C++11） ； p-&gt;*mp ，内置的指向成员指针的指针表达式，其中mp为指向成员函数的指针8； a, b ，内置的逗号表达式，其中b为右值； a ? b : c ，某些三元条件表达式； 至非引用类型的转换表达式，例如： static_cast&lt;double&gt;(x) 、 std::string{} 或 (int)42 ； this指针； lambda表达式，例如： [](int x){ return x * x; }。(since c++11) 。 属性 拥有rvalue的所有属性（稍后介绍）。 prvalue不具备多态性：它所标示的对象的动态型别总是表达式本身的型别。 非自定义类非数组（non-class non-array）的prvalue不能被cv-qualified（不能具备const或volatile属性）。 prvalue不能为不完整的类型（除非它是void类型或出现在decltype表达式中）。 xvalue xvalue ("expiring value")表达式是那些 有身份 且 可以被移动 的表达式。 以下表达式均为xvalue表达式： 返回值为右值引用的函数（的调用）或返回值为右值引用的运算符重载表达式，例如： std::move(x) ； a[n] ，内置的取下标表达式，其中a为一个 右值数组(until C++17) 或 xvalue数组(since C++17) ； a.m ，对象成员表达式，其中a是一个右值且m为非引用类型的非静态数据成员； a.*mp ，对象的成员指针表达式，其中a为右值（rvalue）且mp为指向数据成员的指针； a ? b : c ，某些三元条件表达式； 至右值引用的转换表达式，例如： static_cast&lt;char&amp;&amp;&gt;(x) 。 属性 拥有rvalue的所有属性（稍后介绍）。 拥有glvalue的所有属性（稍后介绍）。 注意：xvalue与rvalue类似，它绑定至右值引用，但xvalue也拥有glvalue的属性，它能被多态化(polymorphic)，且非对象类型的xvalue也能被cv-qualified。 Mixed categories glvalue glvalue 表达式是 lvalue 表达式与 xvalue 表达式的总称（它是一个 lvalue 表达式或 xvalue 表达式）。它 有身份 ，但在 可移动性 上没有硬性规定。 属性 glvalue可以被隐式转换为prvalue，这归功于左值至右值（lvalue-to-rvalue）、数组至指针、函数至指针的隐形转化规则。 glvalue可以被多态化(polymorphic)： 表达式标识对象的动态类型标识符并不总是该对象的静态类型。 在表达式合法的前提下，glvalue可以为不完整的类型。 rvalue rvalue 表达式是 prvalue 表达式和 xvalue 表达式的总称。它 能被移动 ，但对 身份 没有硬性规定。"右值"这个名字具有历史性的意义，它完美的标识了它在CPL编程语言中的作用：赋值运算符的右操作数。 属性 不能获取右值的地址： &amp;int() 、 &amp;i++ 、 &amp;42 和 &amp;std::move(x) 都是不合法的表达式。 不能被用作内置赋值运算符和内置复合赋值运算符的左操作数。 可以被用来初始化常左值引用，此时该右值所标识的对象的生命期将被延续至该常左值引用结束。 可以被用来初始化右值引用，此时该右值所标识对象的生命期将被延续至该右值引用结束。(since c++11) 用作函数实参时(arguments)，若函数拥有两个重载版本（一个使用右值引用形参，一个使用常左值引用形参），该右值将绑定至右值引用版本的重载函数（因此，如果同时拥有拷贝构造函数及移动构造函数，右值实参将会调用移动构造函数，拷贝赋值函数及移动赋值函数亦是如此）(since c++11)。 Special categories Pending member function call 以下两组表达式： a.mf 、 p-&gt;mf (mf为非静态成员函数) 及 a.*mfp 、 p-&gt;*mfp (mfp为指向成员函数的指针)均被标识为prvalue表达式，但它们不能被用来初始化引用，也不能被用作函数实参或其它任何意图，它们只能被用作函数调用操作符的左操作数： (p-&gt;*mfp)(args) 。 Void expressions 返回值为 void 的函数调用表达式、至 void 的转换表达式及抛出异常表达式均被标识为prvalue表达式，但它们不能初始化引用及函数实参。它们可以表示某些空值(discarded-value)内容（例如：仅有该表达式的一行代码、逗号表达式的左操作数等），也可以用作 返回值为void的函数 的返回值。此外，抛出异常表达式也可作为问号条件操作符（ ? ）的第二个或第三个操作数。 Bit fields 位域操作表达式（例如： a.m ，当a为 struct A { int m: 3;} 的左值时）为lvalue表达式：它可以用作赋值操作符的左操作数，但它不能被取地址，也不能被绑定至非常左值引用。常左值引用虽然可以被位域左值初始化，但它只是绑定了该位域的临时拷贝对象，你无法将位域直接绑定至引用。 Footnotes: 1 general lvalue 2 pure rvalue 3 expiring value 4 i是内置类型或重载的前置自增运算符返回左值引用 5 special rvalue category, see pending member function call 6 special rvalue category, see pending member function call 7 special rvalue category, see pending member function call 8 special rvalue category, see pending member function call Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>cppreference</category>
      </categories>
      <tags>
        <tag>cppreference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款2：理解auto类型推导]]></title>
    <url>%2Ftranslation%2Feffective_modern_cpp%2Fitem2.html</url>
    <content type="text"><![CDATA[如果你已经阅读了条款1中关于模板类型推导相关的内容，你应该已经掌握了几乎所有的关于auto类型推导相关的知识，因为与模板类型推导规则相比，auto类型推导规则只有一个例外。这是为什么呢？因为模板类型推导涉及了模板、函数和参数，但auto并不关心那些东西。 是的，但这无所谓。在模板类型推导与auto类型推导之间，有一个直接的映射，可以通过一种方法将他们互相转化。 在条款1中，我们使用如下模板函数对模板类型推导进行讲解： 1 template&lt;typename T&gt; 2 void f(ParamType param); 并使用如下方式调用： 1 f(expr); // call f with some expression 对于函数f的调用，编译器使用expr来推导T和ParamType的类型。 当一个变量被声明为auto，auto便相当与模板中的T，而变量类型描述符1相当与ParamType。当然，示例代码总比口头描述更为清晰，因此，举例如下： 1 auto x = 27; x的类型描述符就是auto本身。而对于如下声明： 1 const auto cx = x; x的类型描述符是const auto。若将声明稍作修改： 1 const auto&amp; rx = x; x的类型描述符便变成了const auto&amp;。因此，对于如上例子中x，cx和rx的类型推导，编译器表现的就像是在用相应的初始化表达式对某一函数模板进行调用一样： 1 teamplate&lt;typename T&gt; 2 void func_for_x(T param); // conceptual template for 3 // deducing x's type 4 5 func_for_x(27); // conceptual call: param's 6 // deduced type is x's type 7 8 9 template&lt;typename T&gt; 10 void func_for_cx(const T param); // conceptual template for 11 // deducing cx's type 12 13 func_for_cx(x); // conceptual call: param's 14 // deduced type is cx's type 15 16 17 template&lt;typename T&gt; 18 void func_for_rx(const T&amp; param); // conceptual template for 19 // deducing rx's type 20 21 func_for_rx(x); // conceptual call: param's 22 // deduced type is rx's type 这正如我之前所诉，auto类型推导与模板类型推导只有在某一特殊情况下才显不同（我们即将讨论）。 条款1将模板类型推导规则依ParamType（模板函数形参的类型描述符）分为三种情况。而在auto变量声明中，类型描述符相当与ParamType，因此也有三种情况： 情形1： 类型描述符是一个指针或引用，但不是通用引用2。 情形2： 类型描述符是一个通用引用。 情形3： 类型描述符不是引用也不是指针。 我们之前已经看过情形1和情形3的例子了： 1 auto x = 27; // case 3 (x is neither ptr nor reference) 2 3 const auto x = x; // case 3 (cx is't either) 4 5 const auto&amp; rx = x; // cast 1 (rx is a non-universal ref.) 当然，情形2也如你所料： 1 auto&amp;&amp; uref1 = x; // x is int and and lvalue, 2 // so uref1's type is int&amp;. 3 4 auto&amp;&amp; uref2 = cx; // cx is const int and lvalue, 5 // so uref2's type is const int&amp;. 6 7 auto&amp;&amp; uref3 = 27; // 27 is in and rvalue, 8 // so uref3's type is int&amp;&amp; 条款1中讲到，数组和函数在传递给非引用类型形参时会退化为相应的指针，当然，此规则对auto类型推导同样适用： 1 const char name[] = "R. N. Briggs"; // name's type is const char[13] 2 3 auto arr1 = name; // arr1's type is const* char 4 5 auto&amp; arr2 = name; // arr2's type is const char (&amp;)[13] 6 7 8 void someFunc(int, double); // someFunc is a function; 9 // type is void (int, double) 10 11 auto func1 = someFunc; // func1's type is void (*)(int, double) 12 13 auto&amp; func2 = soneFunc; // func2's type is void(&amp;)(int, double) 如你所见，auto类型推导与模板类型推导非常相似，它们恰如一枚银币的正反两面。 但有一个例外。我们将从以下情况开始慢慢分析：若用27初始化声明一个int变量，C++98有以下两种方式： 1 int x3 = 27; 2 int x4(27); C++11则提供了统一初始化3支持： 1 int x3 = { 27 }: 2 int x4{ 27 }: 当然，这四行代码结果完全一样，它们都声明了一个初始值为27的整数。 正如条款5所诉，用auto声明变量比通过写出确定的类型来声明变量更具优势，因此，在以上变量声明中，将int替换为auto是一个很明智的做法。替换后的声明如下： auto x1 = 27; auto x2(x1); auto x3 = { 27 }; auto x4{ 27 }; 可是，替换后的声明虽然都能编译通过，却拥有了不同的含义。前两条语句依旧声明一个初始值为27的整数，但后两条语句声明的却是一个仅有一个元素（27）的std::initializer_list&lt;int&gt;！ 1 auto x1 = 27; // type is int, value is 27 2 3 auto x2(27); // ditto 4 5 auto x3 = { 27 }; // type is std::initializer_list&lt;int&gt;, 6 // value is { 27 } 7 8 auto x4{ 27 }; // ditto 这是由auto的一条特殊推导规则决定的。当一使用auto声明的变量使用初始化列表（被{}包围）进行初始化时，它将会被推导为std::initializer_list。如果该类型不能被推导（例如：初始化列表里的元素拥有不同的类型），代码将不能编译通过： 1 auto x5 = { 1, 2, 3.0 }; // error! can't deduce T for 2 // std::initializer_list&lt;T&gt; 正如注释所诉，类型推导将会失败，但重要的是，你必须意识到它其实触发了两条类型推导规则，其一是缘于auto的使用：由于x5使用了初始化列表，它必须被推导为std::initializer_list的一个实例，但std::initializer_list&lt;T&gt;是一个模板，这意味着编译器必须要推导T的类型。因此便触发了第二条类型推导规则。但由于初始化列表中的变量类型并不一致，推导失败。 在auto声明的变量中使用初始化列表，是auto类型推导与模板类型推导的唯一不同。此时该变量将会被推导为std::initializer_list。但将初始化列表传给一个模板函数却是一个错误的行为： 1 auto x = { 11, 23, 9 }; // x's type is 2 // std::initializer_list&lt;int&gt; 3 4 template&lt;typename T&gt; // template with parameter 5 void f(T param); // declaration equivalent to 6 // x's declaration 7 8 f({ 11, 23, 9}); // error! can't deduce type for T 然而，如果将模板的参数声明为某一类型T的初始化列表（std::initializer_list&lt;T&gt;），模板类型推导规则将能正确的推导出T的类型： 1 template&lt;typename T&gt; 2 void f(std::initialer_list&lt;T&gt; initList); 3 4 f({ 11, 23, 9}); // T deduced as int, and initList's 5 // type is std::initializer_list&lt;int&gt; 所以，auto类型推导规则与模板类型推导规则唯一的区别便是，auto会将初始化列表推导为std::initializer_list，这是模板类型推导所不具备的能力。 你或许想知道为何auto类型推导会有这样一条模板类型推导所没有的特殊规则。虽然我也想知道，但遗憾的是，我自己也没有找的一个令人信服的解释。但规则就是规则，你必须要记住： 在用初始化列表初始化一个auto变量时，推导出的类型是std::initializer_list。特别是在你拥抱统一初始化哲学（将初始值用大括号扩起来）时，这点尤为重要。C++11中的一个常见错误就是意外的声明了一个std::initializer_list，这一陷阱导致许多程序员只在必要的时候才会使用大括号进行初始化。（我们将在条款7中讨论何时必须使用大括号） 对于C++11的auto来说，已经没有什么规则可以讲述了，但在最新的C++14标准中，却还有内容需要补充。C++14允许使用auto关键字标明函数返回值需要被推导（参考条款3），也允许在lambda函数中使用auto声明参数。然而，这些对于auto的特殊使用所触发的都是模板的类型推导，而不是auto类型推导。所以，在一个声明为auto返回值的函数中返回一个初始化列表将会编译失败： auto createInitList() { return { 1, 2, 3 }; // error: can't deduce type // for { 1, 2, 3 } } 当然，向lambda函数的auto参数传递初始化列表，也不能编译通过： 1 std::vector&lt;int&gt; v; 2 3 auto resetV = 4 [&amp;v](const auto&amp; newValue) { v = newValue; }; // C++14 5 6 resetV({ 1, 2, 3 }); // error! can't deduce type 7 // for { 1, 2, 3 } 记住： auto类型推导通常与模板类型推导相同，但它拥有一个模板类型推导所不具备的能力：将初始化列表推导为std::initializer_list。 当auto作为函数的返回值或lambda的参数时，使用的是模板类型推导规则，而不是auto类型推导。 Footnotes: 1 type specifier. 2 universal reference. 3 uniform initialization. Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
        <tag>Press Ban</tag>
        <tag>禁止转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条款1：理解模板类型推导]]></title>
    <url>%2Ftranslation%2Feffective_modern_cpp%2Fitem1.html</url>
    <content type="text"><![CDATA[第一章 类型推导 C++98有一套类型推导规则用于函数模板类型的推导。C++11对它稍作修改，并增加了两条： auto 和 decltype 。C++14扩展了 auto 和 decltype 的使用语境。类型推导的普遍应用，将你从手动拼写那些多余且明显的类型的繁重任务中解放出来，它让C++代码更加通用，它会自动的，将你对类型的修改传播到其他地方。当然，它也会让代码行为更难推测，毕竟编译器推导出的类型并不是一直都如你所料。 如果不能对类型推导有一个系统化的了解，就没法用现代的C++编写高效的代码，因为它几乎无处不在：函数模板调用、大多数auto出现的地方、decltype表达式，以及C++14中那奇妙的decltype(auto)构造函数。 这一章节讲述了一些类型推导知识，它们是每一名C++开发者都应掌握的内容。它解释了类型推导的工作原理，并告诉你auto和decltype是如何基于它构建自己的规则系统的。它也会教你如何强迫编译器推导出你所期望的类型结果。 条款1：理解模板类型推导 一些用户虽对某一复杂系统的工作原理及系统设计不甚了解，却仍能愉快的用它解决问题。遵循此道，C++中的模板类型推导不愧为一巨大的成功，不计其数的程序员，都曾通过调用模板函数获得了满意的结果，即便他们对模板类型推导规则不甚清楚。 如果你也是他们中的一员（曾从模板函数中受益的程序员），那我便有一好一坏两个消息要告诉你。好消息是，模板类型推导是构成C++中最引人入胜的新特性 auto 的基础。如果你对C++98的模板类型推导较为熟悉，那么你也已经对C++11的 auto 推导规则有了大概的了解，坏消息是， auto 中的类型推导，很多时候并不像模板类型推导那么直白，因此，对模板类型推导有个全面细致的了解，就显得尤为重要。这条条款将为你详细叙述。 如果你不介意使用部分伪代码，我们便可将一函数模板描述如下： 1 template&lt;typename T&gt; 2 void f(ParamType param); 对它的调用看起来是这样的： 1 f(expr); // call f with some expression 在编译时，编译器使用 expr 来推导两个类型： T 和 ParamType 1，它们通常并不相同， ParamType 经常会包含一些类似于const或引用限定之类的修饰符。比如，一模板声明如下： 1 template&lt;typename T&gt; 2 void f(const T&amp; param); // ParamType is const T&amp; 调用如下： 1 int x = 0; 2 f(x); // call f with an int T被推导为int，但ParamType被推导为const int&amp;。 我们很自然的会认为，T应该被推导为传入的实参类型，即expr的类型。以上例子便是如此：x为int，T也被推导为int。但事实却并非如此，T类型的推导，并不完全取决于expr，它通常也跟ParamType有关。可总结为三种情况： ParamType 是指针或引用，但不是通用引用2(universal reference)。（universal reference将在条款24中详细讲述。再此你只需要知道它确实存在，且与左值引用和右值引用不同即可。） ParamType 是一个通用引用（universal reference）。 ParamType 既不是指针，也不是引用。 因此，我们将对三种情形分别进行讲述，每一情形都将使用如下例子： 1 template&lt;typename T&gt; 2 void f(ParamType param); 3 4 f(expr); // deduce T and ParamType from expr 情形1: ParamType是一个引用或指针，但不是通用引用（universal reference） 最简单的情况就是， ParamType 是一个引用或指针，但不是通用引用（universal reference）。此时的类型推导将遵循如下步骤： 如果 expr 的类型是一个引用，忽略引用部分。 用 expr 的类型来匹配ParamType并决定出T的类型。 例如，针对模板： 1 template&lt;typename T&gt; 2 void f(T&amp; param); // Param is a reference 我们定义如下类型： 1 int x = 27; // x is an int 2 const int cx = x; // cx is a const int 3 const int&amp; rx = x; // rx is a reference to x as a const int 对于以下调用，param及T的类型推导如注释所诉： 1 f(x); // T is int, Param's type is int&amp; 2 3 f(cx); // T is const int, 4 // Param's type is const int&amp; 5 6 f(rx); // T is const int, 7 // Param's type is const int&amp; 在第二、三个调用中，由于cx和rx都是const变量，T便被推导为const int，因此ParamType是const int&amp;。这对调用者非常重要，因为当一个const对象被传递给一个引用参数时，函数的调用者自然会期望这个对象在函数内不能被修改，这便是一个指向常量的引用。因此，向一个模板的T&amp;参数传递一个const对象是安全的：对象的const属性会被推导为T的一部分。 在第三个调用中，需要注意的是，虽然rx的类型是一个引用，T仍然被推导为非引用类型。这是因为在类型推导中，rx的引用属性被忽略了。 上面的例子讲诉的都是左值引用，不过这些推导规则与右值引用完全一致。虽然只有右值才能被传递给右值引用类型的参数，但这一限制与类型推导规则毫不相关。 如果我们将f的参数类型由T&amp;修改为const T&amp;，推导规则将会发生细微的变化，cx和rx的常量性依旧保留，但因为Param的类型是一个常量引用，T的const修饰符便不再需要了： 1 template&lt;typename T&gt; 2 void f(const T&amp; param); // param is now a ref-to-const 3 4 int x = 27; // as before 5 const int cx = x; // as before 6 const int&amp; rx = x; // as before 7 8 f(x); // T is int, param's type is const int&amp; 9 10 f(cx); // T is int, param's type is const int&amp; 11 12 f(rx); // T is int, param's type is const int&amp; 与之前的例子一样，rx的引用属性在推导过程中被忽略了。 当param为指针（或常量指针）时，推导规则与引用一致： 1 template&lt;typename T&gt; 2 void f(T* param); // param is now a pointer 3 4 int x = 27; // as before 5 const int* px = &amp;x; // px is a ptr to x as a const int 6 7 f(&amp;x); // T is int, param's type is int* 8 9 f(px); // T is const int, 10 // param's type is const int* 至此，你可能会感到有点无聊，因为C++的类型推导规则对引用和指针来说是如此的自然，它与你的设想完全一致。 情形2: ParamType是一个通用引用（universal reference） 当模板参数类型为通用引用时，规则就变得有点复杂了。通用引用参数（universal reference parameters）以右值引用的形式声明（例如：对于类型T，通用引用被声明为T&amp;&amp;），它们在被传入左值时，会有不一样的表现。详细情况我们会在条款24中讲诉，在此只做简要概述： 如果 expr 为左值，T和ParamType都会被推导为左值引用。这有两个不寻常点。第一，这是唯一一种T被推导为引用的情况。第二，虽然ParamType被声明为右值引用，它却被推导为一个左值引用。 如果 expr 为右值，推导规则如情形1所诉。 例如： 1 template&lt;typename T&gt; 2 void f(T&amp;&amp; param); // param is now a universal reference 3 4 int x = 27; // as before 5 const int cx = x; // as before 6 const int&amp; rx = x; // as before 7 8 f(x); // x is lvalue, so T is int&amp;, 9 // param's type is also int&amp; 10 11 f(cx); // cx is lvalue, so T is const int&amp;, 12 // param's type is also const int&amp; 13 14 f(rx); // rx is lvalue, so T is const int&amp;, 15 // param's type is also const int&amp;&#728; 16 17 f(27); // 27 is rvalue, so T is int, 18 // param's type is therefore int&amp;&amp; 条款24将对以上例子进行详细解释，这里只需要记住：通用引用的类型推导规则与左、右值引用并不相同，它与传入参数的类型（是左值或右值）有关，这与非通用引用（non-universal references）完全不同。 情形3: ParamType既不是引用也不是指针 当ParamType既不是引用也不是指针时，我们将它按照值传递的方式处理： 1 tamplate&lt;typename T&gt; 2 void f(T param); // param is now passed by value 这意味着Param将会是实参的一个拷贝：一个全新的对象。事实上，也正是这一现象（param将会成为一个新对象）直接导致了T的推导规则必须遵循如下规定： 与之前一样，如果 expr 的类型是一个引用，则忽略引用属性。 忽略引用属性后，如果 expr 带有 const 或 volatile 属性，一并忽略。（volatile属性的对象并不常见，它们通常只会在实现设备驱动程序时使用。详情参考条款40。） 因此： 1 int x = 27; // as before 2 const int cx = x; // as before 3 const int&amp; rx= x; // as before 4 5 f(x); // T's and param's types are both int 6 f(cx); // T's and param's types are again both int 7 f(rx); // T's and param's types are still both int 注意，即便cx和rx都是const变量， param 的类型却不是const。这是有道理的： param 是与它的实参（cx或rx）完全独立的、全新的对象，是实参（cx或rx）的拷贝，因此，实参（cx或rx）不能被修改这样的限制对param完全无效。这就是为什么 expr 的const属性在param的类型推导过程中会被忽略（volatile属性同理）： expr 不能被修改并不意味着它的拷贝不能被修改。 const和volatile属性只有在值传递时才会被忽略，这点非常重要。正如之前所诉，在推导形参为指向常量的引用或指针时， expr 的const属性是不会被忽略的。但当 expr 是一个指向常量的常指针时，将它以值传递方式传递给以下模板会怎样呢？ 1 template&lt;typename T&gt; 2 void f(T param); // param is still passed by value 3 4 const char* const ptr = "Fun with pointers"; // ptr is const pointer to const object 5 6 f(ptr); // pass arg of type const char * const 星号右边的const声明了ptr是一个const变量：ptr不能被指向其它的地方，也不能被设置为null。（星号左边的const表明指向的字符串是常量，该字符串不能被修改。）当ptr被传递给f时，它被按位拷贝给param，因此， 指针自己（ptr）是按值传递的 。根据值传递的推导规则，ptr的const属性将会被忽略，param的类型被推导为const char*，即一个可被修改的指向const字符串的指针（指针的指向可被修改，但其指向的内容不能被修改）。ptr指向的内容的const属性在推导过程中被保留了，但ptr自己的const属性在拷贝生成一个新指针（param）时，被忽略了。 数组实参 之前所诉已是模板推导的主流情形，但还有一个较为罕见的情形需要我们了解：数组与指针其实是不同的，尽管它们大多数情况下可以相互替换使用。数组在很多情况下会退化为指向它第一个元素的地址的指针，这给许多人造成了"数组与指针是一样的"这样的错觉。这种数组到指针的退化，让以下代码变得合法： 1 const char name[] = "J. P. Briggs"; // name's type is 2 // const char[13] 3 4 const char* ptrToName = name; // array decays to pointer const char* 指针ptrToName被const char[13]类型的变量name初始化，它们的类型（const char* 和const char[13]）并不相同，但因这条数组指针退化规则（array-to-pointer）的存在，以上代码可以编译通过。 但当数组以值传递的方式被传给模板时又会怎样呢？ 1 template&lt;typename T&gt; 2 void f(T param); // template with by-value parameter 3 4 f(name); // what types are deduced for T and param? 我们首先应该注意到函数是没有数组类型的参数的。是的，是的，以下语法确实是合法的： 1 void myFunc(int param[]); 但是，数组声明被当成了指针，也就是说myFunc其实和以下声明是一样的： 1 void myFunc(int* param); // same function as above 这种数组与指针参数的等价继承自C++的父亲C，它给人一种数组与指针相同的错觉。 由于数组参数被当成指针参数对待，以值方式传入模板的数组会被推导为指针，因此对于模板函数f的调用，T被推导为const char*： 1 f(name); // name is array, but T deduced as const char* 但出乎意料的是，尽管函数不能声明真正的数组参数，它们却可以声明指向数组的引用作为自己的参数！所以如果我们把模板f修改为接收一个引用作为参数， 1 template&lt;typename T&gt; 2 void f(T&amp; param); // template with by-reference parameter 并向其传入一个数组， 1 f(name); // pass array of f T真的会被推导为数组类型！该类型包含了被传入的数组的大小，针对此例，T被推导为const char[13]，f的参数（指向这个数组的引用）类型为const char (&amp;)[13]。确实，这语法难以理解，但与掌握它所给予你能力的提高相比，消耗的那点精力简直微不足道（Yes, the syntax looks toxic（这语法有毒！）, but knowing it will score you mondo points with those few souls who care.）。 有趣的是，我们可以利用这一技巧（声明指向数组的引用）创建一个模板来推导数组元素的个数。 1 // &#22312;&#32534;&#35793;&#26399;&#36820;&#22238;&#25351;&#23450;&#25968;&#32452;&#30340;&#38271;&#24230;&#12290; 2 // &#65288;&#25968;&#32452;&#24418;&#21442;&#26159;&#19968;&#20010;&#21311;&#21517;&#21442;&#25968;&#65292;&#22240;&#20026;&#25105;&#20204;&#21482;&#20851;&#24515;&#23427;&#25317;&#26377;&#30340;&#20803;&#32032;&#20010;&#25968;&#65289; 3 template&lt;typename T, std::size_t N&gt; 4 constexpr std::size_t arraySize(T (&amp;)[N]) noexpect 5 { 6 // see info below on constexpr and noexcept 7 return N; 8 } 正如条款15所诉，将此函数声明为constexpr将使其结果在编译时被计算。这使得我们可以声明一个其元素个数与某一使用大扩号方式初始化的数组的元素个数相同的数组： 1 int keyValues[] = {1, 3, 7, 9, 11, 22, 35}; // keyValue has 7 elements 2 3 int mappedVals[arraySize(keyValue)]; // so does mappedVals 当然，作为一名现代化的C++程序员，你应当很自然的选择使用std:array代替内置的数组： 1 std::array&lt;int, arraySize(keyValue)&gt; mappedVals; // mappedVals' size is 7 将arraySize声明为noexcept，将使编译器更易于生成更好的代码。详请请看条款14。 函数实参 数组并不是C++中唯一一种会退化为指针的东西。函数也会退化为函数指针，并且我们之前所讨论的数组类型推导的规则对于函数类型推导依旧适用。因此： 1 void someFunc(int, double); // someFunc is a function; 2 // type is void(int, double) 3 4 template&lt;typename T&gt; 5 void f1(T param); // in f1, param passed by value 6 7 template&lt;typename T&gt; 8 void f2(T&amp; param); // in f2, param passed by ref 9 10 f1(someFunc); // param deduced as ptr-to-func; 11 // type is void (*)(int, double) 12 13 f2(someFunc); // param deduced as ref-to-func; 14 // type is void (&amp;)(int, double) 它们（推导为函数指针与推导为函数引用）在使用中没有任何不同，但如果你正在学习数组到指针的退化规则，你应该也要顺道学习以下函数到指针的退化规则。 现在你已经知道了模板类型推导规则，我在条款开始的时候便说，它极其简单，事实上，它大多数时候都很简单。当然，通用引用（universal reference）传入左值实参时可能会略显复杂，还有数组和函数到指针的退化这条规则，可能会让你感到混乱。许多时候，你可能会想”抓住编译器的衣领“向它查问，"告诉我你推导出什么类型！"，那时你就应该转到条款4，它会告诉你如何诱导编译器这么做。 记住： 在模板类型推导过程中，引用实参会被当成非引用实参对待，也就是说实参的引用属性被忽略了。 当模板参数（形参）为通用引用时，左值实参需要特殊对待。 在推导值传递形参的模板时，实参的const和volatile属性被移除。 在推导过程中，数组和函数实参都会被退化为指针，除非它们被用来初始化引用（形参为引用时便是这种情况）。 Footnotes: 1 parameter翻译为形参，argument翻译为实参。本文中的参数一概指形参，在易混淆的地方，会指明是形参或实参。 2 universal reference。 Last Updated 2018-07-05 Thu 01:57. Emacs 27.0.50 (Org mode 9.1.13)]]></content>
      <categories>
        <category>Translation</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
        <tag>Press Ban</tag>
        <tag>禁止转载</tag>
      </tags>
  </entry>
</search>
